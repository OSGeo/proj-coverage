<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - proj.info - src/geodesic.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - geodesic.c<span style="font-size: 80%;"> (source / <a href="geodesic.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">proj.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">926</td>
            <td class="headerCovTableEntry">929</td>
            <td class="headerCovTableEntryHi">99.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-06-07 22:42:34</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">61</td>
            <td class="headerCovTableEntry">61</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**</a>
<span class="lineNum">       2 </span>            :  * \file geodesic.c
<span class="lineNum">       3 </span>            :  * \brief Implementation of the geodesic routines in C
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * For the full documentation see geodesic.h.
<span class="lineNum">       6 </span>            :  **********************************************************************/
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : /** @cond SKIP */
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : /*
<span class="lineNum">      11 </span>            :  * This is a C implementation of the geodesic algorithms described in
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *   C. F. F. Karney,
<span class="lineNum">      14 </span>            :  *   Algorithms for geodesics,
<span class="lineNum">      15 </span>            :  *   J. Geodesy &lt;b&gt;87&lt;/b&gt;, 43--55 (2013);
<span class="lineNum">      16 </span>            :  *   https://doi.org/10.1007/s00190-012-0578-z
<span class="lineNum">      17 </span>            :  *   Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
<span class="lineNum">      18 </span>            :  *
<span class="lineNum">      19 </span>            :  * See the comments in geodesic.h for documentation.
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * Copyright (c) Charles Karney (2012-2018) &lt;charles@karney.com&gt; and licensed
<span class="lineNum">      22 </span>            :  * under the MIT/X11 License.  For more information, see
<span class="lineNum">      23 </span>            :  * https://geographiclib.sourceforge.io/
<span class="lineNum">      24 </span>            :  */
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &quot;geodesic.h&quot;
<span class="lineNum">      27 </span>            : #ifdef PJ_LIB__
<span class="lineNum">      28 </span>            : #include &quot;proj_math.h&quot;
<span class="lineNum">      29 </span>            : #else
<span class="lineNum">      30 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      31 </span>            : #endif
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #if !defined(HAVE_C99_MATH)
<span class="lineNum">      34 </span>            : #define HAVE_C99_MATH 0
<span class="lineNum">      35 </span>            : #endif
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #define GEOGRAPHICLIB_GEODESIC_ORDER 6
<span class="lineNum">      38 </span>            : #define nA1   GEOGRAPHICLIB_GEODESIC_ORDER
<span class="lineNum">      39 </span>            : #define nC1   GEOGRAPHICLIB_GEODESIC_ORDER
<span class="lineNum">      40 </span>            : #define nC1p  GEOGRAPHICLIB_GEODESIC_ORDER
<span class="lineNum">      41 </span>            : #define nA2   GEOGRAPHICLIB_GEODESIC_ORDER
<span class="lineNum">      42 </span>            : #define nC2   GEOGRAPHICLIB_GEODESIC_ORDER
<span class="lineNum">      43 </span>            : #define nA3   GEOGRAPHICLIB_GEODESIC_ORDER
<span class="lineNum">      44 </span>            : #define nA3x  nA3
<span class="lineNum">      45 </span>            : #define nC3   GEOGRAPHICLIB_GEODESIC_ORDER
<span class="lineNum">      46 </span>            : #define nC3x  ((nC3 * (nC3 - 1)) / 2)
<span class="lineNum">      47 </span>            : #define nC4   GEOGRAPHICLIB_GEODESIC_ORDER
<span class="lineNum">      48 </span>            : #define nC4x  ((nC4 * (nC4 + 1)) / 2)
<span class="lineNum">      49 </span>            : #define nC    (GEOGRAPHICLIB_GEODESIC_ORDER + 1)
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : typedef double real;
<span class="lineNum">      52 </span>            : typedef int boolx;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : static unsigned init = 0;
<span class="lineNum">      55 </span>            : static const int FALSE = 0;
<span class="lineNum">      56 </span>            : static const int TRUE = 1;
<span class="lineNum">      57 </span>            : static unsigned digits, maxit1, maxit2;
<span class="lineNum">      58 </span>            : static real epsilon, realmin, pi, degree, NaN,
<a name="59"><span class="lineNum">      59 </span>            :   tiny, tol0, tol1, tol2, tolb, xthresh;</a>
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span><span class="lineCov">       1230 : static void Init() {</span>
<span class="lineNum">      62 </span><span class="lineCov">       1230 :   if (!init) {</span>
<span class="lineNum">      63 </span>            : #if defined(__DBL_MANT_DIG__)
<span class="lineNum">      64 </span><span class="lineCov">       1230 :     digits = __DBL_MANT_DIG__;</span>
<span class="lineNum">      65 </span>            : #else
<span class="lineNum">      66 </span>            :     digits = 53;
<span class="lineNum">      67 </span>            : #endif
<span class="lineNum">      68 </span>            : #if defined(__DBL_EPSILON__)
<span class="lineNum">      69 </span><span class="lineCov">       1230 :     epsilon = __DBL_EPSILON__;</span>
<span class="lineNum">      70 </span>            : #else
<span class="lineNum">      71 </span>            :     epsilon = pow(0.5, digits - 1);
<span class="lineNum">      72 </span>            : #endif
<span class="lineNum">      73 </span>            : #if defined(__DBL_MIN__)
<span class="lineNum">      74 </span><span class="lineCov">       1230 :     realmin = __DBL_MIN__;</span>
<span class="lineNum">      75 </span>            : #else
<span class="lineNum">      76 </span>            :     realmin = pow(0.5, 1022);
<span class="lineNum">      77 </span>            : #endif
<span class="lineNum">      78 </span>            : #if defined(M_PI)
<span class="lineNum">      79 </span><span class="lineCov">       1230 :     pi = M_PI;</span>
<span class="lineNum">      80 </span>            : #else
<span class="lineNum">      81 </span>            :     pi = atan2(0.0, -1.0);
<span class="lineNum">      82 </span>            : #endif
<span class="lineNum">      83 </span><span class="lineCov">       1230 :     maxit1 = 20;</span>
<span class="lineNum">      84 </span><span class="lineCov">       1230 :     maxit2 = maxit1 + digits + 10;</span>
<span class="lineNum">      85 </span><span class="lineCov">       1230 :     tiny = sqrt(realmin);</span>
<span class="lineNum">      86 </span><span class="lineCov">       1230 :     tol0 = epsilon;</span>
<span class="lineNum">      87 </span>            :     /* Increase multiplier in defn of tol1 from 100 to 200 to fix inverse case
<span class="lineNum">      88 </span>            :      * 52.784459512564 0 -52.784459512563990912 179.634407464943777557
<span class="lineNum">      89 </span>            :      * which otherwise failed for Visual Studio 10 (Release and Debug) */
<span class="lineNum">      90 </span><span class="lineCov">       1230 :     tol1 = 200 * tol0;</span>
<span class="lineNum">      91 </span><span class="lineCov">       1230 :     tol2 = sqrt(tol0);</span>
<span class="lineNum">      92 </span>            :     /* Check on bisection interval */
<span class="lineNum">      93 </span><span class="lineCov">       1230 :     tolb = tol0 * tol2;</span>
<span class="lineNum">      94 </span><span class="lineCov">       1230 :     xthresh = 1000 * tol2;</span>
<span class="lineNum">      95 </span><span class="lineCov">       1230 :     degree = pi/180;</span>
<span class="lineNum">      96 </span>            :     #if defined(NAN)
<span class="lineNum">      97 </span><span class="lineCov">       1230 :     NaN = NAN;</span>
<span class="lineNum">      98 </span>            :     #else
<span class="lineNum">      99 </span>            :     {
<span class="lineNum">     100 </span>            :       real minus1 = -1;
<span class="lineNum">     101 </span>            :       /* cppcheck-suppress wrongmathcall */
<span class="lineNum">     102 </span>            :       NaN = sqrt(minus1);
<span class="lineNum">     103 </span>            :     }
<span class="lineNum">     104 </span>            :     #endif
<span class="lineNum">     105 </span><span class="lineCov">       1230 :     init = 1;</span>
<span class="lineNum">     106 </span>            :   }
<span class="lineNum">     107 </span><span class="lineCov">       1230 : }</span>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : enum captype {
<span class="lineNum">     110 </span>            :   CAP_NONE = 0U,
<span class="lineNum">     111 </span>            :   CAP_C1   = 1U&lt;&lt;0,
<span class="lineNum">     112 </span>            :   CAP_C1p  = 1U&lt;&lt;1,
<span class="lineNum">     113 </span>            :   CAP_C2   = 1U&lt;&lt;2,
<span class="lineNum">     114 </span>            :   CAP_C3   = 1U&lt;&lt;3,
<span class="lineNum">     115 </span>            :   CAP_C4   = 1U&lt;&lt;4,
<span class="lineNum">     116 </span>            :   CAP_ALL  = 0x1FU,
<span class="lineNum">     117 </span>            :   OUT_ALL  = 0x7F80U
<a name="118"><span class="lineNum">     118 </span>            : };</a>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineCov">      42929 : static real sq(real x) { return x * x; }</span>
<span class="lineNum">     121 </span>            : #if HAVE_C99_MATH
<span class="lineNum">     122 </span>            : #define atanhx atanh
<span class="lineNum">     123 </span>            : #define copysignx copysign
<span class="lineNum">     124 </span>            : #define hypotx hypot
<span class="lineNum">     125 </span>            : #define cbrtx cbrt
<span class="lineNum">     126 </span>            : #else
<span class="lineNum">     127 </span>            : static real log1px(real x) {
<span class="lineNum">     128 </span>            :   volatile real
<span class="lineNum">     129 </span>            :     y = 1 + x,
<span class="lineNum">     130 </span>            :     z = y - 1;
<span class="lineNum">     131 </span>            :   /* Here's the explanation for this magic: y = 1 + z, exactly, and z
<span class="lineNum">     132 </span>            :    * approx x, thus log(y)/z (which is nearly constant near z = 0) returns
<span class="lineNum">     133 </span>            :    * a good approximation to the true log(1 + x)/x.  The multiplication x *
<span class="lineNum">     134 </span>            :    * (log(y)/z) introduces little additional error. */
<span class="lineNum">     135 </span>            :   return z == 0 ? x : x * log(y) / z;
<span class="lineNum">     136 </span>            : }
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : static real atanhx(real x) {
<span class="lineNum">     139 </span>            :   real y = fabs(x);             /* Enforce odd parity */
<span class="lineNum">     140 </span>            :   y = log1px(2 * y/(1 - y))/2;
<span class="lineNum">     141 </span>            :   return x &lt; 0 ? -y : y;
<span class="lineNum">     142 </span>            : }
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : static real copysignx(real x, real y) {
<span class="lineNum">     145 </span>            :   return fabs(x) * (y &lt; 0 || (y == 0 &amp;&amp; 1/y &lt; 0) ? -1 : 1);
<span class="lineNum">     146 </span>            : }
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : static real hypotx(real x, real y)
<span class="lineNum">     149 </span>            : { return sqrt(x * x + y * y); }
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : static real cbrtx(real x) {
<span class="lineNum">     152 </span>            :   real y = pow(fabs(x), 1/(real)(3)); /* Return the real cube root */
<span class="lineNum">     153 </span>            :   return x &lt; 0 ? -y : y;
<span class="lineNum">     154 </span>            : }
<a name="155"><span class="lineNum">     155 </span>            : #endif</a>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineCov">       6356 : static real sumx(real u, real v, real* t) {</span>
<span class="lineNum">     158 </span><span class="lineCov">       6356 :   volatile real s = u + v;</span>
<span class="lineNum">     159 </span><span class="lineCov">       6356 :   volatile real up = s - v;</span>
<span class="lineNum">     160 </span><span class="lineCov">       6356 :   volatile real vpp = s - up;</span>
<span class="lineNum">     161 </span><span class="lineCov">       6356 :   up -= u;</span>
<span class="lineNum">     162 </span><span class="lineCov">       6356 :   vpp -= v;</span>
<span class="lineNum">     163 </span><span class="lineCov">       6356 :   if (t) *t = -(up + vpp);</span>
<span class="lineNum">     164 </span>            :   /* error-free sum:
<span class="lineNum">     165 </span>            :    * u + v =       s      + t
<span class="lineNum">     166 </span>            :    *       = round(u + v) + t */
<span class="lineNum">     167 </span><span class="lineCov">       6356 :   return s;</span>
<a name="168"><span class="lineNum">     168 </span>            : }</a>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineCov">     184179 : static real polyval(int N, const real p[], real x) {</span>
<span class="lineNum">     171 </span><span class="lineCov">     184179 :   real y = N &lt; 0 ? 0 : *p++;</span>
<span class="lineNum">     172 </span><span class="lineCov">     184179 :   while (--N &gt;= 0) y = y * x + *p++;</span>
<span class="lineNum">     173 </span><span class="lineCov">     184179 :   return y;</span>
<span class="lineNum">     174 </span>            : }
<a name="175"><span class="lineNum">     175 </span>            : </a>
<span class="lineNum">     176 </span>            : /* mimic C++ std::min and std::max */
<span class="lineNum">     177 </span><span class="lineCov">       2476 : static real minx(real a, real b)</span>
<a name="178"><span class="lineNum">     178 </span><span class="lineCov">       2476 : { return (b &lt; a) ? b : a; }</span></a>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineCov">      13613 : static real maxx(real a, real b)</span>
<a name="181"><span class="lineNum">     181 </span><span class="lineCov">      13613 : { return (a &lt; b) ? b : a; }</span></a>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">       5902 : static void swapx(real* x, real* y)</span>
<a name="184"><span class="lineNum">     184 </span><span class="lineCov">       5902 : { real t = *x; *x = *y; *y = t; }</span></a>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span><span class="lineCov">      16052 : static void norm2(real* sinx, real* cosx) {</span>
<span class="lineNum">     187 </span><span class="lineCov">      16052 :   real r = hypotx(*sinx, *cosx);</span>
<span class="lineNum">     188 </span><span class="lineCov">      16052 :   *sinx /= r;</span>
<span class="lineNum">     189 </span><span class="lineCov">      16052 :   *cosx /= r;</span>
<a name="190"><span class="lineNum">     190 </span><span class="lineCov">      16052 : }</span></a>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineCov">      12964 : static real AngNormalize(real x) {</span>
<span class="lineNum">     193 </span>            : #if HAVE_C99_MATH
<span class="lineNum">     194 </span><span class="lineCov">      12964 :   x = remainder(x, (real)(360));</span>
<span class="lineNum">     195 </span><span class="lineCov">      12964 :   return x != -180 ? x : 180;</span>
<span class="lineNum">     196 </span>            : #else
<span class="lineNum">     197 </span>            :   real y = fmod(x, (real)(360));
<span class="lineNum">     198 </span>            : #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
<span class="lineNum">     199 </span>            :   /*
<span class="lineNum">     200 </span>            :    * Before version 14 (2015), Visual Studio had problems dealing
<span class="lineNum">     201 </span>            :    * with -0.0.  Specifically
<span class="lineNum">     202 </span>            :    *   VC 10,11,12 and 32-bit compile: fmod(-0.0, 360.0) -&gt; +0.0
<span class="lineNum">     203 </span>            :    * sincosdx has a similar fix.
<span class="lineNum">     204 </span>            :    * python 2.7 on Windows 32-bit machines has the same problem.
<span class="lineNum">     205 </span>            :    */
<span class="lineNum">     206 </span>            :   if (x == 0) y = x;
<span class="lineNum">     207 </span>            : #endif
<span class="lineNum">     208 </span>            :   return y &lt;= -180 ? y + 360 : (y &lt;= 180 ? y : y - 360);
<span class="lineNum">     209 </span>            : #endif
<a name="210"><span class="lineNum">     210 </span>            : }</a>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineCov">       6398 : static real LatFix(real x)</span>
<a name="213"><span class="lineNum">     213 </span><span class="lineCov">       6398 : { return fabs(x) &gt; 90 ? NaN : x; }</span></a>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span><span class="lineCov">       2886 : static real AngDiff(real x, real y, real* e) {</span>
<span class="lineNum">     216 </span><span class="lineCov">       2886 :   real t, d = AngNormalize(sumx(AngNormalize(-x), AngNormalize(y), &amp;t));</span>
<span class="lineNum">     217 </span>            :   /* Here y - x = d + t (mod 360), exactly, where d is in (-180,180] and
<span class="lineNum">     218 </span>            :    * abs(t) &lt;= eps (eps = 2^-45 for doubles).  The only case where the
<span class="lineNum">     219 </span>            :    * addition of t takes the result outside the range (-180,180] is d = 180
<span class="lineNum">     220 </span>            :    * and t &gt; 0.  The case, d = -180 + eps, t = -eps, can't happen, since
<span class="lineNum">     221 </span>            :    * sum would have returned the exact result in such a case (i.e., given t
<span class="lineNum">     222 </span>            :    * = 0). */
<span class="lineNum">     223 </span><span class="lineCov">       2886 :   return sumx(d == 180 &amp;&amp; t &gt; 0 ? -180 : d, t, e);</span>
<a name="224"><span class="lineNum">     224 </span>            : }</a>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineCov">      12790 : static real AngRound(real x) {</span>
<span class="lineNum">     227 </span><span class="lineCov">      12790 :   const real z = 1/(real)(16);</span>
<span class="lineNum">     228 </span>            :   volatile real y;
<span class="lineNum">     229 </span><span class="lineCov">      12790 :   if (x == 0) return 0;</span>
<span class="lineNum">     230 </span><span class="lineCov">      10496 :   y = fabs(x);</span>
<span class="lineNum">     231 </span>            :   /* The compiler mustn't &quot;simplify&quot; z - (z - y) to y */
<span class="lineNum">     232 </span><span class="lineCov">      10496 :   y = y &lt; z ? z - (z - y) : y;</span>
<span class="lineNum">     233 </span><span class="lineCov">      10496 :   return x &lt; 0 ? -y : y;</span>
<a name="234"><span class="lineNum">     234 </span>            : }</a>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineCov">      10156 : static void sincosdx(real x, real* sinx, real* cosx) {</span>
<span class="lineNum">     237 </span>            :   /* In order to minimize round-off errors, this function exactly reduces
<span class="lineNum">     238 </span>            :    * the argument to the range [-45, 45] before converting it to radians. */
<span class="lineNum">     239 </span>            :   real r, s, c; int q;
<span class="lineNum">     240 </span>            : #if HAVE_C99_MATH &amp;&amp; !defined(__GNUC__)
<span class="lineNum">     241 </span>            :   /* Disable for gcc because of bug in glibc version &lt; 2.22, see
<span class="lineNum">     242 </span>            :    * https://sourceware.org/bugzilla/show_bug.cgi?id=17569 */
<span class="lineNum">     243 </span>            :   r = remquo(x, (real)(90), &amp;q);
<span class="lineNum">     244 </span>            : #else
<span class="lineNum">     245 </span><span class="lineCov">      10156 :   r = fmod(x, (real)(360));</span>
<span class="lineNum">     246 </span>            :   /* check for NaN */
<span class="lineNum">     247 </span><span class="lineCov">      10156 :   q = r == r ? (int)(floor(r / 90 + (real)(0.5))) : 0;</span>
<span class="lineNum">     248 </span><span class="lineCov">      10156 :   r -= 90 * q;</span>
<span class="lineNum">     249 </span>            : #endif
<span class="lineNum">     250 </span>            :   /* now abs(r) &lt;= 45 */
<span class="lineNum">     251 </span><span class="lineCov">      10156 :   r *= degree;</span>
<span class="lineNum">     252 </span>            :   /* Possibly could call the gnu extension sincos */
<span class="lineNum">     253 </span><span class="lineCov">      10156 :   s = sin(r); c = cos(r);</span>
<span class="lineNum">     254 </span>            : #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
<span class="lineNum">     255 </span>            :   /*
<span class="lineNum">     256 </span>            :    * Before version 14 (2015), Visual Studio had problems dealing
<span class="lineNum">     257 </span>            :    * with -0.0.  Specifically
<span class="lineNum">     258 </span>            :    *   VC 10,11,12 and 32-bit compile: fmod(-0.0, 360.0) -&gt; +0.0
<span class="lineNum">     259 </span>            :    *   VC 12       and 64-bit compile:  sin(-0.0)        -&gt; +0.0
<span class="lineNum">     260 </span>            :    * AngNormalize has a similar fix.
<span class="lineNum">     261 </span>            :    * python 2.7 on Windows 32-bit machines has the same problem.
<span class="lineNum">     262 </span>            :    */
<span class="lineNum">     263 </span>            :   if (x == 0) s = x;
<span class="lineNum">     264 </span>            : #endif
<span class="lineNum">     265 </span><span class="lineCov">      10156 :   switch ((unsigned)q &amp; 3U) {</span>
<span class="lineNum">     266 </span><span class="lineCov">       6940 :   case 0U: *sinx =  s; *cosx =  c; break;</span>
<span class="lineNum">     267 </span><span class="lineCov">       1664 :   case 1U: *sinx =  c; *cosx = -s; break;</span>
<span class="lineNum">     268 </span><span class="lineCov">        138 :   case 2U: *sinx = -s; *cosx = -c; break;</span>
<span class="lineNum">     269 </span><span class="lineCov">       1414 :   default: *sinx = -c; *cosx =  s; break; /* case 3U */</span>
<span class="lineNum">     270 </span>            :   }
<span class="lineNum">     271 </span><span class="lineCov">      10156 :   if (x != 0) { *sinx += (real)(0); *cosx += (real)(0); }</span>
<a name="272"><span class="lineNum">     272 </span><span class="lineCov">      10156 : }</span></a>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineCov">       6934 : static real atan2dx(real y, real x) {</span>
<span class="lineNum">     275 </span>            :   /* In order to minimize round-off errors, this function rearranges the
<span class="lineNum">     276 </span>            :    * arguments so that result of atan2 is in the range [-pi/4, pi/4] before
<span class="lineNum">     277 </span>            :    * converting it to degrees and mapping the result to the correct
<span class="lineNum">     278 </span>            :    * quadrant. */
<span class="lineNum">     279 </span><span class="lineCov">       6934 :   int q = 0; real ang;</span>
<span class="lineNum">     280 </span><span class="lineCov">       6934 :   if (fabs(y) &gt; fabs(x)) { swapx(&amp;x, &amp;y); q = 2; }</span>
<span class="lineNum">     281 </span><span class="lineCov">       6934 :   if (x &lt; 0) { x = -x; ++q; }</span>
<span class="lineNum">     282 </span>            :   /* here x &gt;= 0 and x &gt;= abs(y), so angle is in [-pi/4, pi/4] */
<span class="lineNum">     283 </span><span class="lineCov">       6934 :   ang = atan2(y, x) / degree;</span>
<span class="lineNum">     284 </span><span class="lineCov">       6934 :   switch (q) {</span>
<span class="lineNum">     285 </span>            :     /* Note that atan2d(-0.0, 1.0) will return -0.  However, we expect that
<span class="lineNum">     286 </span>            :      * atan2d will not be called with y = -0.  If need be, include
<span class="lineNum">     287 </span>            :      *
<span class="lineNum">     288 </span>            :      *   case 0: ang = 0 + ang; break;
<span class="lineNum">     289 </span>            :      */
<span class="lineNum">     290 </span><span class="lineCov">       2070 :   case 1: ang = (y &gt;= 0 ? 180 : -180) - ang; break;</span>
<span class="lineNum">     291 </span><span class="lineCov">       2434 :   case 2: ang =  90 - ang; break;</span>
<span class="lineNum">     292 </span><span class="lineCov">        462 :   case 3: ang = -90 + ang; break;</span>
<span class="lineNum">     293 </span>            :   }
<span class="lineNum">     294 </span><span class="lineCov">       6934 :   return ang;</span>
<span class="lineNum">     295 </span>            : }
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : static void A3coeff(struct geod_geodesic* g);
<span class="lineNum">     298 </span>            : static void C3coeff(struct geod_geodesic* g);
<span class="lineNum">     299 </span>            : static void C4coeff(struct geod_geodesic* g);
<span class="lineNum">     300 </span>            : static real SinCosSeries(boolx sinp,
<span class="lineNum">     301 </span>            :                          real sinx, real cosx,
<span class="lineNum">     302 </span>            :                          const real c[], int n);
<span class="lineNum">     303 </span>            : static void Lengths(const struct geod_geodesic* g,
<span class="lineNum">     304 </span>            :                     real eps, real sig12,
<span class="lineNum">     305 </span>            :                     real ssig1, real csig1, real dn1,
<span class="lineNum">     306 </span>            :                     real ssig2, real csig2, real dn2,
<span class="lineNum">     307 </span>            :                     real cbet1, real cbet2,
<span class="lineNum">     308 </span>            :                     real* ps12b, real* pm12b, real* pm0,
<span class="lineNum">     309 </span>            :                     real* pM12, real* pM21,
<span class="lineNum">     310 </span>            :                     /* Scratch area of the right size */
<span class="lineNum">     311 </span>            :                     real Ca[]);
<span class="lineNum">     312 </span>            : static real Astroid(real x, real y);
<span class="lineNum">     313 </span>            : static real InverseStart(const struct geod_geodesic* g,
<span class="lineNum">     314 </span>            :                          real sbet1, real cbet1, real dn1,
<span class="lineNum">     315 </span>            :                          real sbet2, real cbet2, real dn2,
<span class="lineNum">     316 </span>            :                          real lam12, real slam12, real clam12,
<span class="lineNum">     317 </span>            :                          real* psalp1, real* pcalp1,
<span class="lineNum">     318 </span>            :                          /* Only updated if return val &gt;= 0 */
<span class="lineNum">     319 </span>            :                          real* psalp2, real* pcalp2,
<span class="lineNum">     320 </span>            :                          /* Only updated for short lines */
<span class="lineNum">     321 </span>            :                          real* pdnm,
<span class="lineNum">     322 </span>            :                          /* Scratch area of the right size */
<span class="lineNum">     323 </span>            :                          real Ca[]);
<span class="lineNum">     324 </span>            : static real Lambda12(const struct geod_geodesic* g,
<span class="lineNum">     325 </span>            :                      real sbet1, real cbet1, real dn1,
<span class="lineNum">     326 </span>            :                      real sbet2, real cbet2, real dn2,
<span class="lineNum">     327 </span>            :                      real salp1, real calp1,
<span class="lineNum">     328 </span>            :                      real slam120, real clam120,
<span class="lineNum">     329 </span>            :                      real* psalp2, real* pcalp2,
<span class="lineNum">     330 </span>            :                      real* psig12,
<span class="lineNum">     331 </span>            :                      real* pssig1, real* pcsig1,
<span class="lineNum">     332 </span>            :                      real* pssig2, real* pcsig2,
<span class="lineNum">     333 </span>            :                      real* peps,
<span class="lineNum">     334 </span>            :                      real* pdomg12,
<span class="lineNum">     335 </span>            :                      boolx diffp, real* pdlam12,
<span class="lineNum">     336 </span>            :                      /* Scratch area of the right size */
<span class="lineNum">     337 </span>            :                      real Ca[]);
<span class="lineNum">     338 </span>            : static real A3f(const struct geod_geodesic* g, real eps);
<span class="lineNum">     339 </span>            : static void C3f(const struct geod_geodesic* g, real eps, real c[]);
<span class="lineNum">     340 </span>            : static void C4f(const struct geod_geodesic* g, real eps, real c[]);
<span class="lineNum">     341 </span>            : static real A1m1f(real eps);
<span class="lineNum">     342 </span>            : static void C1f(real eps, real c[]);
<span class="lineNum">     343 </span>            : static void C1pf(real eps, real c[]);
<span class="lineNum">     344 </span>            : static real A2m1f(real eps);
<span class="lineNum">     345 </span>            : static void C2f(real eps, real c[]);
<span class="lineNum">     346 </span>            : static int transit(real lon1, real lon2);
<span class="lineNum">     347 </span>            : static int transitdirect(real lon1, real lon2);
<span class="lineNum">     348 </span>            : static void accini(real s[]);
<span class="lineNum">     349 </span>            : static void acccopy(const real s[], real t[]);
<span class="lineNum">     350 </span>            : static void accadd(real s[], real y);
<span class="lineNum">     351 </span>            : static real accsum(const real s[], real y);
<a name="352"><span class="lineNum">     352 </span>            : static void accneg(real s[]);</a>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineCov">       2462 : void geod_init(struct geod_geodesic* g, real a, real f) {</span>
<span class="lineNum">     355 </span><span class="lineCov">       2462 :   if (!init) Init();</span>
<span class="lineNum">     356 </span><span class="lineCov">       2462 :   g-&gt;a = a;</span>
<span class="lineNum">     357 </span><span class="lineCov">       2462 :   g-&gt;f = f;</span>
<span class="lineNum">     358 </span><span class="lineCov">       2462 :   g-&gt;f1 = 1 - g-&gt;f;</span>
<span class="lineNum">     359 </span><span class="lineCov">       2462 :   g-&gt;e2 = g-&gt;f * (2 - g-&gt;f);</span>
<span class="lineNum">     360 </span><span class="lineCov">       2462 :   g-&gt;ep2 = g-&gt;e2 / sq(g-&gt;f1);   /* e2 / (1 - e2) */</span>
<span class="lineNum">     361 </span><span class="lineCov">       2462 :   g-&gt;n = g-&gt;f / ( 2 - g-&gt;f);</span>
<span class="lineNum">     362 </span><span class="lineCov">       2462 :   g-&gt;b = g-&gt;a * g-&gt;f1;</span>
<span class="lineNum">     363 </span><span class="lineCov">       7386 :   g-&gt;c2 = (sq(g-&gt;a) + sq(g-&gt;b) *</span>
<span class="lineNum">     364 </span><span class="lineCov">       4663 :            (g-&gt;e2 == 0 ? 1 :</span>
<span class="lineNum">     365 </span><span class="lineCov">       2201 :             (g-&gt;e2 &gt; 0 ? atanhx(sqrt(g-&gt;e2)) : atan(sqrt(-g-&gt;e2))) /</span>
<span class="lineNum">     366 </span><span class="lineCov">       4663 :             sqrt(fabs(g-&gt;e2))))/2; /* authalic radius squared */</span>
<span class="lineNum">     367 </span>            :   /* The sig12 threshold for &quot;really short&quot;.  Using the auxiliary sphere
<span class="lineNum">     368 </span>            :    * solution with dnm computed at (bet1 + bet2) / 2, the relative error in the
<span class="lineNum">     369 </span>            :    * azimuth consistency check is sig12^2 * abs(f) * min(1, 1-f/2) / 2.  (Error
<span class="lineNum">     370 </span>            :    * measured for 1/100 &lt; b/a &lt; 100 and abs(f) &gt;= 1/1000.  For a given f and
<span class="lineNum">     371 </span>            :    * sig12, the max error occurs for lines near the pole.  If the old rule for
<span class="lineNum">     372 </span>            :    * computing dnm = (dn1 + dn2)/2 is used, then the error increases by a
<span class="lineNum">     373 </span>            :    * factor of 2.)  Setting this equal to epsilon gives sig12 = etol2.  Here
<span class="lineNum">     374 </span>            :    * 0.1 is a safety factor (error decreased by 100) and max(0.001, abs(f))
<span class="lineNum">     375 </span>            :    * stops etol2 getting too large in the nearly spherical case. */
<span class="lineNum">     376 </span><span class="lineCov">       4924 :   g-&gt;etol2 = 0.1 * tol2 /</span>
<span class="lineNum">     377 </span><span class="lineCov">       2462 :     sqrt( maxx((real)(0.001), fabs(g-&gt;f)) * minx((real)(1), 1 - g-&gt;f/2) / 2 );</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineCov">       2462 :   A3coeff(g);</span>
<span class="lineNum">     380 </span><span class="lineCov">       2462 :   C3coeff(g);</span>
<span class="lineNum">     381 </span><span class="lineCov">       2462 :   C4coeff(g);</span>
<a name="382"><span class="lineNum">     382 </span><span class="lineCov">       2462 : }</span></a>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineCov">       1038 : static void geod_lineinit_int(struct geod_geodesicline* l,</span>
<span class="lineNum">     385 </span>            :                               const struct geod_geodesic* g,
<span class="lineNum">     386 </span>            :                               real lat1, real lon1,
<span class="lineNum">     387 </span>            :                               real azi1, real salp1, real calp1,
<span class="lineNum">     388 </span>            :                               unsigned caps) {
<span class="lineNum">     389 </span>            :   real cbet1, sbet1, eps;
<span class="lineNum">     390 </span><span class="lineCov">       1038 :   l-&gt;a = g-&gt;a;</span>
<span class="lineNum">     391 </span><span class="lineCov">       1038 :   l-&gt;f = g-&gt;f;</span>
<span class="lineNum">     392 </span><span class="lineCov">       1038 :   l-&gt;b = g-&gt;b;</span>
<span class="lineNum">     393 </span><span class="lineCov">       1038 :   l-&gt;c2 = g-&gt;c2;</span>
<span class="lineNum">     394 </span><span class="lineCov">       1038 :   l-&gt;f1 = g-&gt;f1;</span>
<span class="lineNum">     395 </span>            :   /* If caps is 0 assume the standard direct calculation */
<span class="lineNum">     396 </span><span class="lineCov">       1038 :   l-&gt;caps = (caps ? caps : GEOD_DISTANCE_IN | GEOD_LONGITUDE) |</span>
<span class="lineNum">     397 </span>            :     /* always allow latitude and azimuth and unrolling of longitude */
<span class="lineNum">     398 </span><span class="lineCov">       1038 :     GEOD_LATITUDE | GEOD_AZIMUTH | GEOD_LONG_UNROLL;</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineCov">       1038 :   l-&gt;lat1 = LatFix(lat1);</span>
<span class="lineNum">     401 </span><span class="lineCov">       1038 :   l-&gt;lon1 = lon1;</span>
<span class="lineNum">     402 </span><span class="lineCov">       1038 :   l-&gt;azi1 = azi1;</span>
<span class="lineNum">     403 </span><span class="lineCov">       1038 :   l-&gt;salp1 = salp1;</span>
<span class="lineNum">     404 </span><span class="lineCov">       1038 :   l-&gt;calp1 = calp1;</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineCov">       1038 :   sincosdx(AngRound(l-&gt;lat1), &amp;sbet1, &amp;cbet1); sbet1 *= l-&gt;f1;</span>
<span class="lineNum">     407 </span>            :   /* Ensure cbet1 = +epsilon at poles */
<span class="lineNum">     408 </span><span class="lineCov">       1038 :   norm2(&amp;sbet1, &amp;cbet1); cbet1 = maxx(tiny, cbet1);</span>
<span class="lineNum">     409 </span><span class="lineCov">       1038 :   l-&gt;dn1 = sqrt(1 + g-&gt;ep2 * sq(sbet1));</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   /* Evaluate alp0 from sin(alp1) * cos(bet1) = sin(alp0), */
<span class="lineNum">     412 </span><span class="lineCov">       1038 :   l-&gt;salp0 = l-&gt;salp1 * cbet1; /* alp0 in [0, pi/2 - |bet1|] */</span>
<span class="lineNum">     413 </span>            :   /* Alt: calp0 = hypot(sbet1, calp1 * cbet1).  The following
<span class="lineNum">     414 </span>            :    * is slightly better (consider the case salp1 = 0). */
<span class="lineNum">     415 </span><span class="lineCov">       1038 :   l-&gt;calp0 = hypotx(l-&gt;calp1, l-&gt;salp1 * sbet1);</span>
<span class="lineNum">     416 </span>            :   /* Evaluate sig with tan(bet1) = tan(sig1) * cos(alp1).
<span class="lineNum">     417 </span>            :    * sig = 0 is nearest northward crossing of equator.
<span class="lineNum">     418 </span>            :    * With bet1 = 0, alp1 = pi/2, we have sig1 = 0 (equatorial line).
<span class="lineNum">     419 </span>            :    * With bet1 =  pi/2, alp1 = -pi, sig1 =  pi/2
<span class="lineNum">     420 </span>            :    * With bet1 = -pi/2, alp1 =  0 , sig1 = -pi/2
<span class="lineNum">     421 </span>            :    * Evaluate omg1 with tan(omg1) = sin(alp0) * tan(sig1).
<span class="lineNum">     422 </span>            :    * With alp0 in (0, pi/2], quadrants for sig and omg coincide.
<span class="lineNum">     423 </span>            :    * No atan2(0,0) ambiguity at poles since cbet1 = +epsilon.
<span class="lineNum">     424 </span>            :    * With alp0 = 0, omg1 = 0 for alp1 = 0, omg1 = pi for alp1 = pi. */
<span class="lineNum">     425 </span><span class="lineCov">       1038 :   l-&gt;ssig1 = sbet1; l-&gt;somg1 = l-&gt;salp0 * sbet1;</span>
<span class="lineNum">     426 </span><span class="lineCov">       1038 :   l-&gt;csig1 = l-&gt;comg1 = sbet1 != 0 || l-&gt;calp1 != 0 ? cbet1 * l-&gt;calp1 : 1;</span>
<span class="lineNum">     427 </span><span class="lineCov">       1038 :   norm2(&amp;l-&gt;ssig1, &amp;l-&gt;csig1); /* sig1 in (-pi, pi] */</span>
<span class="lineNum">     428 </span>            :   /* norm2(somg1, comg1); -- don't need to normalize! */
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineCov">       1038 :   l-&gt;k2 = sq(l-&gt;calp0) * g-&gt;ep2;</span>
<span class="lineNum">     431 </span><span class="lineCov">       1038 :   eps = l-&gt;k2 / (2 * (1 + sqrt(1 + l-&gt;k2)) + l-&gt;k2);</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineCov">       1038 :   if (l-&gt;caps &amp; CAP_C1) {</span>
<span class="lineNum">     434 </span>            :     real s, c;
<span class="lineNum">     435 </span><span class="lineCov">       1036 :     l-&gt;A1m1 = A1m1f(eps);</span>
<span class="lineNum">     436 </span><span class="lineCov">       1036 :     C1f(eps, l-&gt;C1a);</span>
<span class="lineNum">     437 </span><span class="lineCov">       1036 :     l-&gt;B11 = SinCosSeries(TRUE, l-&gt;ssig1, l-&gt;csig1, l-&gt;C1a, nC1);</span>
<span class="lineNum">     438 </span><span class="lineCov">       1036 :     s = sin(l-&gt;B11); c = cos(l-&gt;B11);</span>
<span class="lineNum">     439 </span>            :     /* tau1 = sig1 + B11 */
<span class="lineNum">     440 </span><span class="lineCov">       1036 :     l-&gt;stau1 = l-&gt;ssig1 * c + l-&gt;csig1 * s;</span>
<span class="lineNum">     441 </span><span class="lineCov">       1036 :     l-&gt;ctau1 = l-&gt;csig1 * c - l-&gt;ssig1 * s;</span>
<span class="lineNum">     442 </span>            :     /* Not necessary because C1pa reverts C1a
<span class="lineNum">     443 </span>            :      *    B11 = -SinCosSeries(TRUE, stau1, ctau1, C1pa, nC1p); */
<span class="lineNum">     444 </span>            :   }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineCov">       1038 :   if (l-&gt;caps &amp; CAP_C1p)</span>
<span class="lineNum">     447 </span><span class="lineCov">        996 :     C1pf(eps, l-&gt;C1pa);</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineCov">       1038 :   if (l-&gt;caps &amp; CAP_C2) {</span>
<span class="lineNum">     450 </span><span class="lineCov">         82 :     l-&gt;A2m1 = A2m1f(eps);</span>
<span class="lineNum">     451 </span><span class="lineCov">         82 :     C2f(eps, l-&gt;C2a);</span>
<span class="lineNum">     452 </span><span class="lineCov">         82 :     l-&gt;B21 = SinCosSeries(TRUE, l-&gt;ssig1, l-&gt;csig1, l-&gt;C2a, nC2);</span>
<span class="lineNum">     453 </span>            :   }
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineCov">       1038 :   if (l-&gt;caps &amp; CAP_C3) {</span>
<span class="lineNum">     456 </span><span class="lineCov">       1032 :     C3f(g, eps, l-&gt;C3a);</span>
<span class="lineNum">     457 </span><span class="lineCov">       1032 :     l-&gt;A3c = -l-&gt;f * l-&gt;salp0 * A3f(g, eps);</span>
<span class="lineNum">     458 </span><span class="lineCov">       1032 :     l-&gt;B31 = SinCosSeries(TRUE, l-&gt;ssig1, l-&gt;csig1, l-&gt;C3a, nC3-1);</span>
<span class="lineNum">     459 </span>            :   }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineCov">       1038 :   if (l-&gt;caps &amp; CAP_C4) {</span>
<span class="lineNum">     462 </span><span class="lineCov">        114 :     C4f(g, eps, l-&gt;C4a);</span>
<span class="lineNum">     463 </span>            :     /* Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0) */
<span class="lineNum">     464 </span><span class="lineCov">        114 :     l-&gt;A4 = sq(l-&gt;a) * l-&gt;calp0 * l-&gt;salp0 * g-&gt;e2;</span>
<span class="lineNum">     465 </span><span class="lineCov">        114 :     l-&gt;B41 = SinCosSeries(FALSE, l-&gt;ssig1, l-&gt;csig1, l-&gt;C4a, nC4);</span>
<span class="lineNum">     466 </span>            :   }
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineCov">       1038 :   l-&gt;a13 = l-&gt;s13 = NaN;</span>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">       1038 : }</span></a>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineCov">       1032 : void geod_lineinit(struct geod_geodesicline* l,</span>
<span class="lineNum">     472 </span>            :                    const struct geod_geodesic* g,
<span class="lineNum">     473 </span>            :                    real lat1, real lon1, real azi1, unsigned caps) {
<span class="lineNum">     474 </span>            :   real salp1, calp1;
<span class="lineNum">     475 </span><span class="lineCov">       1032 :   azi1 = AngNormalize(azi1);</span>
<span class="lineNum">     476 </span>            :   /* Guard against underflow in salp0 */
<span class="lineNum">     477 </span><span class="lineCov">       1032 :   sincosdx(AngRound(azi1), &amp;salp1, &amp;calp1);</span>
<span class="lineNum">     478 </span><span class="lineCov">       1032 :   geod_lineinit_int(l, g, lat1, lon1, azi1, salp1, calp1, caps);</span>
<a name="479"><span class="lineNum">     479 </span><span class="lineCov">       1032 : }</span></a>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">          2 : void geod_gendirectline(struct geod_geodesicline* l,</span>
<span class="lineNum">     482 </span>            :                         const struct geod_geodesic* g,
<span class="lineNum">     483 </span>            :                         real lat1, real lon1, real azi1,
<span class="lineNum">     484 </span>            :                         unsigned flags, real s12_a12,
<span class="lineNum">     485 </span>            :                         unsigned caps) {
<span class="lineNum">     486 </span><span class="lineCov">          2 :   geod_lineinit(l, g, lat1, lon1, azi1, caps);</span>
<span class="lineNum">     487 </span><span class="lineCov">          2 :   geod_gensetdistance(l, flags, s12_a12);</span>
<a name="488"><span class="lineNum">     488 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineCov">          2 : void geod_directline(struct geod_geodesicline* l,</span>
<span class="lineNum">     491 </span>            :                         const struct geod_geodesic* g,
<span class="lineNum">     492 </span>            :                         real lat1, real lon1, real azi1,
<span class="lineNum">     493 </span>            :                         real s12, unsigned caps) {
<span class="lineNum">     494 </span><span class="lineCov">          2 :   geod_gendirectline(l, g, lat1, lon1, azi1, GEOD_NOFLAGS, s12, caps);</span>
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineCov">       1052 : real geod_genposition(const struct geod_geodesicline* l,</span>
<span class="lineNum">     498 </span>            :                       unsigned flags, real s12_a12,
<span class="lineNum">     499 </span>            :                       real* plat2, real* plon2, real* pazi2,
<span class="lineNum">     500 </span>            :                       real* ps12, real* pm12,
<span class="lineNum">     501 </span>            :                       real* pM12, real* pM21,
<span class="lineNum">     502 </span>            :                       real* pS12) {
<span class="lineNum">     503 </span><span class="lineCov">       1052 :   real lat2 = 0, lon2 = 0, azi2 = 0, s12 = 0,</span>
<span class="lineNum">     504 </span><span class="lineCov">       1052 :     m12 = 0, M12 = 0, M21 = 0, S12 = 0;</span>
<span class="lineNum">     505 </span>            :   /* Avoid warning about uninitialized B12. */
<span class="lineNum">     506 </span><span class="lineCov">       1052 :   real sig12, ssig12, csig12, B12 = 0, AB1 = 0;</span>
<span class="lineNum">     507 </span>            :   real omg12, lam12, lon12;
<span class="lineNum">     508 </span>            :   real ssig2, csig2, sbet2, cbet2, somg2, comg2, salp2, calp2, dn2;
<span class="lineNum">     509 </span><span class="lineCov">       1052 :   unsigned outmask =</span>
<span class="lineNum">     510 </span><span class="lineCov">       2104 :     (plat2 ? GEOD_LATITUDE : 0U) |</span>
<span class="lineNum">     511 </span><span class="lineCov">       2104 :     (plon2 ? GEOD_LONGITUDE : 0U) |</span>
<span class="lineNum">     512 </span><span class="lineCov">       2104 :     (pazi2 ? GEOD_AZIMUTH : 0U) |</span>
<span class="lineNum">     513 </span><span class="lineCov">       2104 :     (ps12 ? GEOD_DISTANCE : 0U) |</span>
<span class="lineNum">     514 </span><span class="lineCov">       2104 :     (pm12 ? GEOD_REDUCEDLENGTH : 0U) |</span>
<span class="lineNum">     515 </span><span class="lineCov">       1052 :     (pM12 || pM21 ? GEOD_GEODESICSCALE : 0U) |</span>
<span class="lineNum">     516 </span><span class="lineCov">       1052 :     (pS12 ? GEOD_AREA : 0U);</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineCov">       1052 :   outmask &amp;= l-&gt;caps &amp; OUT_ALL;</span>
<span class="lineNum">     519 </span><span class="lineCov">       2104 :   if (!( TRUE /*Init()*/ &amp;&amp;</span>
<span class="lineNum">     520 </span><span class="lineCov">       2058 :          (flags &amp; GEOD_ARCMODE || (l-&gt;caps &amp; (GEOD_DISTANCE_IN &amp; OUT_ALL))) ))</span>
<span class="lineNum">     521 </span>            :     /* Uninitialized or impossible distance calculation requested */
<span class="lineNum">     522 </span><span class="lineCov">          2 :     return NaN;</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineCov">       1050 :   if (flags &amp; GEOD_ARCMODE) {</span>
<span class="lineNum">     525 </span>            :     /* Interpret s12_a12 as spherical arc length */
<span class="lineNum">     526 </span><span class="lineCov">         46 :     sig12 = s12_a12 * degree;</span>
<span class="lineNum">     527 </span><span class="lineCov">         46 :     sincosdx(s12_a12, &amp;ssig12, &amp;csig12);</span>
<span class="lineNum">     528 </span>            :   } else {
<span class="lineNum">     529 </span>            :     /* Interpret s12_a12 as distance */
<span class="lineNum">     530 </span>            :     real
<span class="lineNum">     531 </span><span class="lineCov">       1004 :       tau12 = s12_a12 / (l-&gt;b * (1 + l-&gt;A1m1)),</span>
<span class="lineNum">     532 </span><span class="lineCov">       1004 :       s = sin(tau12),</span>
<span class="lineNum">     533 </span><span class="lineCov">       1004 :       c = cos(tau12);</span>
<span class="lineNum">     534 </span>            :     /* tau2 = tau1 + tau12 */
<span class="lineNum">     535 </span><span class="lineCov">       2008 :     B12 = - SinCosSeries(TRUE,</span>
<span class="lineNum">     536 </span><span class="lineCov">       1004 :                          l-&gt;stau1 * c + l-&gt;ctau1 * s,</span>
<span class="lineNum">     537 </span><span class="lineCov">       1004 :                          l-&gt;ctau1 * c - l-&gt;stau1 * s,</span>
<span class="lineNum">     538 </span><span class="lineCov">       1004 :                          l-&gt;C1pa, nC1p);</span>
<span class="lineNum">     539 </span><span class="lineCov">       1004 :     sig12 = tau12 - (B12 - l-&gt;B11);</span>
<span class="lineNum">     540 </span><span class="lineCov">       1004 :     ssig12 = sin(sig12); csig12 = cos(sig12);</span>
<span class="lineNum">     541 </span><span class="lineCov">       1004 :     if (fabs(l-&gt;f) &gt; 0.01) {</span>
<span class="lineNum">     542 </span>            :       /* Reverted distance series is inaccurate for |f| &gt; 1/100, so correct
<span class="lineNum">     543 </span>            :        * sig12 with 1 Newton iteration.  The following table shows the
<span class="lineNum">     544 </span>            :        * approximate maximum error for a = WGS_a() and various f relative to
<span class="lineNum">     545 </span>            :        * GeodesicExact.
<span class="lineNum">     546 </span>            :        *     erri = the error in the inverse solution (nm)
<span class="lineNum">     547 </span>            :        *     errd = the error in the direct solution (series only) (nm)
<span class="lineNum">     548 </span>            :        *     errda = the error in the direct solution (series + 1 Newton) (nm)
<span class="lineNum">     549 </span>            :        *
<span class="lineNum">     550 </span>            :        *       f     erri  errd errda
<span class="lineNum">     551 </span>            :        *     -1/5    12e6 1.2e9  69e6
<span class="lineNum">     552 </span>            :        *     -1/10  123e3  12e6 765e3
<span class="lineNum">     553 </span>            :        *     -1/20   1110 108e3  7155
<span class="lineNum">     554 </span>            :        *     -1/50  18.63 200.9 27.12
<span class="lineNum">     555 </span>            :        *     -1/100 18.63 23.78 23.37
<span class="lineNum">     556 </span>            :        *     -1/150 18.63 21.05 20.26
<span class="lineNum">     557 </span>            :        *      1/150 22.35 24.73 25.83
<span class="lineNum">     558 </span>            :        *      1/100 22.35 25.03 25.31
<span class="lineNum">     559 </span>            :        *      1/50  29.80 231.9 30.44
<span class="lineNum">     560 </span>            :        *      1/20   5376 146e3  10e3
<span class="lineNum">     561 </span>            :        *      1/10  829e3  22e6 1.5e6
<span class="lineNum">     562 </span>            :        *      1/5   157e6 3.8e9 280e6 */
<span class="lineNum">     563 </span>            :       real serr;
<span class="lineNum">     564 </span><span class="lineCov">          2 :       ssig2 = l-&gt;ssig1 * csig12 + l-&gt;csig1 * ssig12;</span>
<span class="lineNum">     565 </span><span class="lineCov">          2 :       csig2 = l-&gt;csig1 * csig12 - l-&gt;ssig1 * ssig12;</span>
<span class="lineNum">     566 </span><span class="lineCov">          2 :       B12 = SinCosSeries(TRUE, ssig2, csig2, l-&gt;C1a, nC1);</span>
<span class="lineNum">     567 </span><span class="lineCov">          2 :       serr = (1 + l-&gt;A1m1) * (sig12 + (B12 - l-&gt;B11)) - s12_a12 / l-&gt;b;</span>
<span class="lineNum">     568 </span><span class="lineCov">          2 :       sig12 = sig12 - serr / sqrt(1 + l-&gt;k2 * sq(ssig2));</span>
<span class="lineNum">     569 </span><span class="lineCov">          2 :       ssig12 = sin(sig12); csig12 = cos(sig12);</span>
<span class="lineNum">     570 </span>            :       /* Update B12 below */
<span class="lineNum">     571 </span>            :     }
<span class="lineNum">     572 </span>            :   }
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            :   /* sig2 = sig1 + sig12 */
<span class="lineNum">     575 </span><span class="lineCov">       1050 :   ssig2 = l-&gt;ssig1 * csig12 + l-&gt;csig1 * ssig12;</span>
<span class="lineNum">     576 </span><span class="lineCov">       1050 :   csig2 = l-&gt;csig1 * csig12 - l-&gt;ssig1 * ssig12;</span>
<span class="lineNum">     577 </span><span class="lineCov">       1050 :   dn2 = sqrt(1 + l-&gt;k2 * sq(ssig2));</span>
<span class="lineNum">     578 </span><span class="lineCov">       1050 :   if (outmask &amp; (GEOD_DISTANCE | GEOD_REDUCEDLENGTH | GEOD_GEODESICSCALE)) {</span>
<span class="lineNum">     579 </span><span class="lineCov">         90 :     if (flags &amp; GEOD_ARCMODE || fabs(l-&gt;f) &gt; 0.01)</span>
<span class="lineNum">     580 </span><span class="lineCov">         46 :       B12 = SinCosSeries(TRUE, ssig2, csig2, l-&gt;C1a, nC1);</span>
<span class="lineNum">     581 </span><span class="lineCov">         90 :     AB1 = (1 + l-&gt;A1m1) * (B12 - l-&gt;B11);</span>
<span class="lineNum">     582 </span>            :   }
<span class="lineNum">     583 </span>            :   /* sin(bet2) = cos(alp0) * sin(sig2) */
<span class="lineNum">     584 </span><span class="lineCov">       1050 :   sbet2 = l-&gt;calp0 * ssig2;</span>
<span class="lineNum">     585 </span>            :   /* Alt: cbet2 = hypot(csig2, salp0 * ssig2); */
<span class="lineNum">     586 </span><span class="lineCov">       1050 :   cbet2 = hypotx(l-&gt;salp0, l-&gt;calp0 * csig2);</span>
<span class="lineNum">     587 </span><span class="lineCov">       1050 :   if (cbet2 == 0)</span>
<span class="lineNum">     588 </span>            :     /* I.e., salp0 = 0, csig2 = 0.  Break the degeneracy in this case */
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     cbet2 = csig2 = tiny;</span>
<span class="lineNum">     590 </span>            :   /* tan(alp0) = cos(sig2)*tan(alp2) */
<span class="lineNum">     591 </span><span class="lineCov">       1050 :   salp2 = l-&gt;salp0; calp2 = l-&gt;calp0 * csig2; /* No need to normalize */</span>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span><span class="lineCov">       1050 :   if (outmask &amp; GEOD_DISTANCE)</span>
<span class="lineNum">     594 </span><span class="lineCov">        100 :     s12 = (flags &amp; GEOD_ARCMODE) ?</span>
<span class="lineNum">     595 </span><span class="lineCov">         50 :       l-&gt;b * ((1 + l-&gt;A1m1) * sig12 + AB1) :</span>
<span class="lineNum">     596 </span>            :       s12_a12;
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineCov">       1050 :   if (outmask &amp; GEOD_LONGITUDE) {</span>
<span class="lineNum">     599 </span><span class="lineCov">       1038 :     real E = copysignx(1, l-&gt;salp0); /* east or west going? */</span>
<span class="lineNum">     600 </span>            :     /* tan(omg2) = sin(alp0) * tan(sig2) */
<span class="lineNum">     601 </span><span class="lineCov">       1038 :     somg2 = l-&gt;salp0 * ssig2; comg2 = csig2;  /* No need to normalize */</span>
<span class="lineNum">     602 </span>            :     /* omg12 = omg2 - omg1 */
<span class="lineNum">     603 </span><span class="lineCov">       2076 :     omg12 = (flags &amp; GEOD_LONG_UNROLL)</span>
<span class="lineNum">     604 </span>            :       ? E * (sig12
<span class="lineNum">     605 </span><span class="lineCov">        126 :              - (atan2(    ssig2, csig2) - atan2(    l-&gt;ssig1, l-&gt;csig1))</span>
<span class="lineNum">     606 </span><span class="lineCov">        126 :              + (atan2(E * somg2, comg2) - atan2(E * l-&gt;somg1, l-&gt;comg1)))</span>
<span class="lineNum">     607 </span><span class="lineCov">       2076 :       : atan2(somg2 * l-&gt;comg1 - comg2 * l-&gt;somg1,</span>
<span class="lineNum">     608 </span><span class="lineCov">        912 :               comg2 * l-&gt;comg1 + somg2 * l-&gt;somg1);</span>
<span class="lineNum">     609 </span><span class="lineCov">       2076 :     lam12 = omg12 + l-&gt;A3c *</span>
<span class="lineNum">     610 </span><span class="lineCov">       2076 :       ( sig12 + (SinCosSeries(TRUE, ssig2, csig2, l-&gt;C3a, nC3-1)</span>
<span class="lineNum">     611 </span><span class="lineCov">       1038 :                  - l-&gt;B31));</span>
<span class="lineNum">     612 </span><span class="lineCov">       1038 :     lon12 = lam12 / degree;</span>
<span class="lineNum">     613 </span><span class="lineCov">       1950 :     lon2 = (flags &amp; GEOD_LONG_UNROLL) ? l-&gt;lon1 + lon12 :</span>
<span class="lineNum">     614 </span><span class="lineCov">        912 :       AngNormalize(AngNormalize(l-&gt;lon1) + AngNormalize(lon12));</span>
<span class="lineNum">     615 </span>            :   }
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineCov">       1050 :   if (outmask &amp; GEOD_LATITUDE)</span>
<span class="lineNum">     618 </span><span class="lineCov">       1038 :     lat2 = atan2dx(sbet2, l-&gt;f1 * cbet2);</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">       1050 :   if (outmask &amp; GEOD_AZIMUTH)</span>
<span class="lineNum">     621 </span><span class="lineCov">       1008 :     azi2 = atan2dx(salp2, calp2);</span>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineCov">       1050 :   if (outmask &amp; (GEOD_REDUCEDLENGTH | GEOD_GEODESICSCALE)) {</span>
<span class="lineNum">     624 </span>            :     real
<span class="lineNum">     625 </span><span class="lineCov">         84 :       B22 = SinCosSeries(TRUE, ssig2, csig2, l-&gt;C2a, nC2),</span>
<span class="lineNum">     626 </span><span class="lineCov">         84 :       AB2 = (1 + l-&gt;A2m1) * (B22 - l-&gt;B21),</span>
<span class="lineNum">     627 </span><span class="lineCov">         84 :       J12 = (l-&gt;A1m1 - l-&gt;A2m1) * sig12 + (AB1 - AB2);</span>
<span class="lineNum">     628 </span><span class="lineCov">         84 :     if (outmask &amp; GEOD_REDUCEDLENGTH)</span>
<span class="lineNum">     629 </span>            :       /* Add parens around (csig1 * ssig2) and (ssig1 * csig2) to ensure
<span class="lineNum">     630 </span>            :        * accurate cancellation in the case of coincident points. */
<span class="lineNum">     631 </span><span class="lineCov">        168 :       m12 = l-&gt;b * ((dn2 * (l-&gt;csig1 * ssig2) - l-&gt;dn1 * (l-&gt;ssig1 * csig2))</span>
<span class="lineNum">     632 </span><span class="lineCov">         84 :                     - l-&gt;csig1 * csig2 * J12);</span>
<span class="lineNum">     633 </span><span class="lineCov">         84 :     if (outmask &amp; GEOD_GEODESICSCALE) {</span>
<span class="lineNum">     634 </span><span class="lineCov">        168 :       real t = l-&gt;k2 * (ssig2 - l-&gt;ssig1) * (ssig2 + l-&gt;ssig1) /</span>
<span class="lineNum">     635 </span><span class="lineCov">         84 :         (l-&gt;dn1 + dn2);</span>
<span class="lineNum">     636 </span><span class="lineCov">         84 :       M12 = csig12 + (t *  ssig2 -  csig2 * J12) * l-&gt;ssig1 / l-&gt;dn1;</span>
<span class="lineNum">     637 </span><span class="lineCov">         84 :       M21 = csig12 - (t * l-&gt;ssig1 - l-&gt;csig1 * J12) *  ssig2 /  dn2;</span>
<span class="lineNum">     638 </span>            :     }
<span class="lineNum">     639 </span>            :   }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineCov">       1050 :   if (outmask &amp; GEOD_AREA) {</span>
<span class="lineNum">     642 </span>            :     real
<span class="lineNum">     643 </span><span class="lineCov">        116 :       B42 = SinCosSeries(FALSE, ssig2, csig2, l-&gt;C4a, nC4);</span>
<span class="lineNum">     644 </span>            :     real salp12, calp12;
<span class="lineNum">     645 </span><span class="lineCov">        116 :     if (l-&gt;calp0 == 0 || l-&gt;salp0 == 0) {</span>
<span class="lineNum">     646 </span>            :       /* alp12 = alp2 - alp1, used in atan2 so no need to normalize */
<span class="lineNum">     647 </span><span class="lineCov">          8 :       salp12 = salp2 * l-&gt;calp1 - calp2 * l-&gt;salp1;</span>
<span class="lineNum">     648 </span><span class="lineCov">          8 :       calp12 = calp2 * l-&gt;calp1 + salp2 * l-&gt;salp1;</span>
<span class="lineNum">     649 </span>            :     } else {
<span class="lineNum">     650 </span>            :       /* tan(alp) = tan(alp0) * sec(sig)
<span class="lineNum">     651 </span>            :        * tan(alp2-alp1) = (tan(alp2) -tan(alp1)) / (tan(alp2)*tan(alp1)+1)
<span class="lineNum">     652 </span>            :        * = calp0 * salp0 * (csig1-csig2) / (salp0^2 + calp0^2 * csig1*csig2)
<span class="lineNum">     653 </span>            :        * If csig12 &gt; 0, write
<span class="lineNum">     654 </span>            :        *   csig1 - csig2 = ssig12 * (csig1 * ssig12 / (1 + csig12) + ssig1)
<span class="lineNum">     655 </span>            :        * else
<span class="lineNum">     656 </span>            :        *   csig1 - csig2 = csig1 * (1 - csig12) + ssig12 * ssig1
<span class="lineNum">     657 </span>            :        * No need to normalize */
<span class="lineNum">     658 </span><span class="lineCov">        216 :       salp12 = l-&gt;calp0 * l-&gt;salp0 *</span>
<span class="lineNum">     659 </span><span class="lineCov">        172 :         (csig12 &lt;= 0 ? l-&gt;csig1 * (1 - csig12) + ssig12 * l-&gt;ssig1 :</span>
<span class="lineNum">     660 </span><span class="lineCov">         64 :          ssig12 * (l-&gt;csig1 * ssig12 / (1 + csig12) + l-&gt;ssig1));</span>
<span class="lineNum">     661 </span><span class="lineCov">        108 :       calp12 = sq(l-&gt;salp0) + sq(l-&gt;calp0) * l-&gt;csig1 * csig2;</span>
<span class="lineNum">     662 </span>            :     }
<span class="lineNum">     663 </span><span class="lineCov">        116 :     S12 = l-&gt;c2 * atan2(salp12, calp12) + l-&gt;A4 * (B42 - l-&gt;B41);</span>
<span class="lineNum">     664 </span>            :   }
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :   /* In the pattern
<span class="lineNum">     667 </span>            :    *
<span class="lineNum">     668 </span>            :    *   if ((outmask &amp; GEOD_XX) &amp;&amp; pYY)
<span class="lineNum">     669 </span>            :    *     *pYY = YY;
<span class="lineNum">     670 </span>            :    *
<span class="lineNum">     671 </span>            :    * the second check &quot;&amp;&amp; pYY&quot; is redundant.  It's there to make the CLang
<span class="lineNum">     672 </span>            :    * static analyzer happy.
<span class="lineNum">     673 </span>            :    */
<span class="lineNum">     674 </span><span class="lineCov">       1050 :   if ((outmask &amp; GEOD_LATITUDE) &amp;&amp; plat2)</span>
<span class="lineNum">     675 </span><span class="lineCov">       1038 :     *plat2 = lat2;</span>
<span class="lineNum">     676 </span><span class="lineCov">       1050 :   if ((outmask &amp; GEOD_LONGITUDE) &amp;&amp; plon2)</span>
<span class="lineNum">     677 </span><span class="lineCov">       1038 :     *plon2 = lon2;</span>
<span class="lineNum">     678 </span><span class="lineCov">       1050 :   if ((outmask &amp; GEOD_AZIMUTH) &amp;&amp; pazi2)</span>
<span class="lineNum">     679 </span><span class="lineCov">       1008 :     *pazi2 = azi2;</span>
<span class="lineNum">     680 </span><span class="lineCov">       1050 :   if ((outmask &amp; GEOD_DISTANCE) &amp;&amp; ps12)</span>
<span class="lineNum">     681 </span><span class="lineCov">         50 :     *ps12 = s12;</span>
<span class="lineNum">     682 </span><span class="lineCov">       1050 :   if ((outmask &amp; GEOD_REDUCEDLENGTH) &amp;&amp; pm12)</span>
<span class="lineNum">     683 </span><span class="lineCov">         84 :     *pm12 = m12;</span>
<span class="lineNum">     684 </span><span class="lineCov">       1050 :   if (outmask &amp; GEOD_GEODESICSCALE) {</span>
<span class="lineNum">     685 </span><span class="lineCov">         84 :     if (pM12) *pM12 = M12;</span>
<span class="lineNum">     686 </span><span class="lineCov">         84 :     if (pM21) *pM21 = M21;</span>
<span class="lineNum">     687 </span>            :   }
<span class="lineNum">     688 </span><span class="lineCov">       1050 :   if ((outmask &amp; GEOD_AREA) &amp;&amp; pS12)</span>
<span class="lineNum">     689 </span><span class="lineCov">        116 :     *pS12 = S12;</span>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span><span class="lineCov">       1050 :   return (flags &amp; GEOD_ARCMODE) ? s12_a12 : sig12 / degree;</span>
<a name="692"><span class="lineNum">     692 </span>            : }</a>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineCov">          2 : void geod_setdistance(struct geod_geodesicline* l, real s13) {</span>
<span class="lineNum">     695 </span><span class="lineCov">          2 :   l-&gt;s13 = s13;</span>
<span class="lineNum">     696 </span><span class="lineCov">          2 :   l-&gt;a13 = geod_genposition(l, GEOD_NOFLAGS, l-&gt;s13, 0, 0, 0, 0, 0, 0, 0, 0);</span>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">          6 : static void geod_setarc(struct geod_geodesicline* l, real a13) {</span>
<span class="lineNum">     700 </span><span class="lineCov">          6 :   l-&gt;a13 = a13; l-&gt;s13 = NaN;</span>
<span class="lineNum">     701 </span><span class="lineCov">          6 :   geod_genposition(l, GEOD_ARCMODE, l-&gt;a13, 0, 0, 0, &amp;l-&gt;s13, 0, 0, 0, 0);</span>
<a name="702"><span class="lineNum">     702 </span><span class="lineCov">          6 : }</span></a>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineCov">          2 : void geod_gensetdistance(struct geod_geodesicline* l,</span>
<span class="lineNum">     705 </span>            :  unsigned flags, real s13_a13) {
<span class="lineNum">     706 </span><span class="lineCov">          2 :   (flags &amp; GEOD_ARCMODE) ?</span>
<span class="lineNum">     707 </span><span class="lineCov">          2 :     geod_setarc(l, s13_a13) :</span>
<span class="lineNum">     708 </span><span class="lineCov">          2 :     geod_setdistance(l, s13_a13);</span>
<a name="709"><span class="lineNum">     709 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineCov">          4 : void geod_position(const struct geod_geodesicline* l, real s12,</span>
<span class="lineNum">     712 </span>            :                    real* plat2, real* plon2, real* pazi2) {
<span class="lineNum">     713 </span><span class="lineCov">          4 :   geod_genposition(l, FALSE, s12, plat2, plon2, pazi2, 0, 0, 0, 0, 0);</span>
<a name="714"><span class="lineNum">     714 </span><span class="lineCov">          4 : }</span></a>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">       1026 : real geod_gendirect(const struct geod_geodesic* g,</span>
<span class="lineNum">     717 </span>            :                     real lat1, real lon1, real azi1,
<span class="lineNum">     718 </span>            :                     unsigned flags, real s12_a12,
<span class="lineNum">     719 </span>            :                     real* plat2, real* plon2, real* pazi2,
<span class="lineNum">     720 </span>            :                     real* ps12, real* pm12, real* pM12, real* pM21,
<span class="lineNum">     721 </span>            :                     real* pS12) {
<span class="lineNum">     722 </span>            :   struct geod_geodesicline l;
<span class="lineNum">     723 </span><span class="lineCov">       1026 :   unsigned outmask =</span>
<span class="lineNum">     724 </span><span class="lineCov">       2052 :     (plat2 ? GEOD_LATITUDE : 0U) |</span>
<span class="lineNum">     725 </span><span class="lineCov">       2052 :     (plon2 ? GEOD_LONGITUDE : 0U) |</span>
<span class="lineNum">     726 </span><span class="lineCov">       2052 :     (pazi2 ? GEOD_AZIMUTH : 0U) |</span>
<span class="lineNum">     727 </span><span class="lineCov">       2052 :     (ps12 ? GEOD_DISTANCE : 0U) |</span>
<span class="lineNum">     728 </span><span class="lineCov">       2052 :     (pm12 ? GEOD_REDUCEDLENGTH : 0U) |</span>
<span class="lineNum">     729 </span><span class="lineCov">       1026 :     (pM12 || pM21 ? GEOD_GEODESICSCALE : 0U) |</span>
<span class="lineNum">     730 </span><span class="lineCov">       1026 :     (pS12 ? GEOD_AREA : 0U);</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineCov">       1026 :   geod_lineinit(&amp;l, g, lat1, lon1, azi1,</span>
<span class="lineNum">     733 </span>            :                 /* Automatically supply GEOD_DISTANCE_IN if necessary */
<span class="lineNum">     734 </span>            :                 outmask |
<span class="lineNum">     735 </span><span class="lineCov">       1026 :                 ((flags &amp; GEOD_ARCMODE) ? GEOD_NONE : GEOD_DISTANCE_IN));</span>
<span class="lineNum">     736 </span><span class="lineCov">       1026 :   return geod_genposition(&amp;l, flags, s12_a12,</span>
<span class="lineNum">     737 </span>            :                           plat2, plon2, pazi2, ps12, pm12, pM12, pM21, pS12);
<a name="738"><span class="lineNum">     738 </span>            : }</a>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineCov">        908 : void geod_direct(const struct geod_geodesic* g,</span>
<span class="lineNum">     741 </span>            :                  real lat1, real lon1, real azi1,
<span class="lineNum">     742 </span>            :                  real s12,
<span class="lineNum">     743 </span>            :                  real* plat2, real* plon2, real* pazi2) {
<span class="lineNum">     744 </span><span class="lineCov">        908 :   geod_gendirect(g, lat1, lon1, azi1, GEOD_NOFLAGS, s12, plat2, plon2, pazi2,</span>
<span class="lineNum">     745 </span>            :                  0, 0, 0, 0, 0);
<a name="746"><span class="lineNum">     746 </span><span class="lineCov">        908 : }</span></a>
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span><span class="lineCov">       2680 : static real geod_geninverse_int(const struct geod_geodesic* g,</span>
<span class="lineNum">     749 </span>            :                                 real lat1, real lon1, real lat2, real lon2,
<span class="lineNum">     750 </span>            :                                 real* ps12,
<span class="lineNum">     751 </span>            :                                 real* psalp1, real* pcalp1,
<span class="lineNum">     752 </span>            :                                 real* psalp2, real* pcalp2,
<span class="lineNum">     753 </span>            :                                 real* pm12, real* pM12, real* pM21,
<span class="lineNum">     754 </span>            :                                 real* pS12) {
<span class="lineNum">     755 </span><span class="lineCov">       2680 :   real s12 = 0, m12 = 0, M12 = 0, M21 = 0, S12 = 0;</span>
<span class="lineNum">     756 </span>            :   real lon12, lon12s;
<span class="lineNum">     757 </span>            :   int latsign, lonsign, swapp;
<span class="lineNum">     758 </span><span class="lineCov">       2680 :   real sbet1, cbet1, sbet2, cbet2, s12x = 0, m12x = 0;</span>
<span class="lineNum">     759 </span>            :   real dn1, dn2, lam12, slam12, clam12;
<span class="lineNum">     760 </span><span class="lineCov">       2680 :   real a12 = 0, sig12, calp1 = 0, salp1 = 0, calp2 = 0, salp2 = 0;</span>
<span class="lineNum">     761 </span>            :   real Ca[nC];
<span class="lineNum">     762 </span>            :   boolx meridian;
<span class="lineNum">     763 </span>            :   /* somg12 &gt; 1 marks that it needs to be calculated */
<span class="lineNum">     764 </span><span class="lineCov">       2680 :   real omg12 = 0, somg12 = 2, comg12 = 0;</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineCov">       2680 :   unsigned outmask =</span>
<span class="lineNum">     767 </span><span class="lineCov">       5360 :     (ps12 ? GEOD_DISTANCE : 0U) |</span>
<span class="lineNum">     768 </span><span class="lineCov">       5360 :     (pm12 ? GEOD_REDUCEDLENGTH : 0U) |</span>
<span class="lineNum">     769 </span><span class="lineCov">       2680 :     (pM12 || pM21 ? GEOD_GEODESICSCALE : 0U) |</span>
<span class="lineNum">     770 </span><span class="lineCov">       2680 :     (pS12 ? GEOD_AREA : 0U);</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineCov">       2680 :   outmask &amp;= OUT_ALL;</span>
<span class="lineNum">     773 </span>            :   /* Compute longitude difference (AngDiff does this carefully).  Result is
<span class="lineNum">     774 </span>            :    * in [-180, 180] but -180 is only for west-going geodesics.  180 is for
<span class="lineNum">     775 </span>            :    * east-going and meridional geodesics. */
<span class="lineNum">     776 </span><span class="lineCov">       2680 :   lon12 = AngDiff(lon1, lon2, &amp;lon12s);</span>
<span class="lineNum">     777 </span>            :   /* Make longitude difference positive. */
<span class="lineNum">     778 </span><span class="lineCov">       2680 :   lonsign = lon12 &gt;= 0 ? 1 : -1;</span>
<span class="lineNum">     779 </span>            :   /* If very close to being on the same half-meridian, then make it so. */
<span class="lineNum">     780 </span><span class="lineCov">       2680 :   lon12 = lonsign * AngRound(lon12);</span>
<span class="lineNum">     781 </span><span class="lineCov">       2680 :   lon12s = AngRound((180 - lon12) - lonsign * lon12s);</span>
<span class="lineNum">     782 </span><span class="lineCov">       2680 :   lam12 = lon12 * degree;</span>
<span class="lineNum">     783 </span><span class="lineCov">       2680 :   if (lon12 &gt; 90) {</span>
<span class="lineNum">     784 </span><span class="lineCov">        796 :     sincosdx(lon12s, &amp;slam12, &amp;clam12);</span>
<span class="lineNum">     785 </span><span class="lineCov">        796 :     clam12 = -clam12;</span>
<span class="lineNum">     786 </span>            :   } else
<span class="lineNum">     787 </span><span class="lineCov">       1884 :     sincosdx(lon12, &amp;slam12, &amp;clam12);</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            :   /* If really close to the equator, treat as on equator. */
<span class="lineNum">     790 </span><span class="lineCov">       2680 :   lat1 = AngRound(LatFix(lat1));</span>
<span class="lineNum">     791 </span><span class="lineCov">       2680 :   lat2 = AngRound(LatFix(lat2));</span>
<span class="lineNum">     792 </span>            :   /* Swap points so that point with higher (abs) latitude is point 1
<span class="lineNum">     793 </span>            :    * If one latitude is a nan, then it becomes lat1. */
<span class="lineNum">     794 </span><span class="lineCov">       2680 :   swapp = fabs(lat1) &lt; fabs(lat2) ? -1 : 1;</span>
<span class="lineNum">     795 </span><span class="lineCov">       2680 :   if (swapp &lt; 0) {</span>
<span class="lineNum">     796 </span><span class="lineCov">        996 :     lonsign *= -1;</span>
<span class="lineNum">     797 </span><span class="lineCov">        996 :     swapx(&amp;lat1, &amp;lat2);</span>
<span class="lineNum">     798 </span>            :   }
<span class="lineNum">     799 </span>            :   /* Make lat1 &lt;= 0 */
<span class="lineNum">     800 </span><span class="lineCov">       2680 :   latsign = lat1 &lt; 0 ? 1 : -1;</span>
<span class="lineNum">     801 </span><span class="lineCov">       2680 :   lat1 *= latsign;</span>
<span class="lineNum">     802 </span><span class="lineCov">       2680 :   lat2 *= latsign;</span>
<span class="lineNum">     803 </span>            :   /* Now we have
<span class="lineNum">     804 </span>            :    *
<span class="lineNum">     805 </span>            :    *     0 &lt;= lon12 &lt;= 180
<span class="lineNum">     806 </span>            :    *     -90 &lt;= lat1 &lt;= 0
<span class="lineNum">     807 </span>            :    *     lat1 &lt;= lat2 &lt;= -lat1
<span class="lineNum">     808 </span>            :    *
<span class="lineNum">     809 </span>            :    * longsign, swapp, latsign register the transformation to bring the
<span class="lineNum">     810 </span>            :    * coordinates to this canonical form.  In all cases, 1 means no change was
<span class="lineNum">     811 </span>            :    * made.  We make these transformations so that there are few cases to
<span class="lineNum">     812 </span>            :    * check, e.g., on verifying quadrants in atan2.  In addition, this
<span class="lineNum">     813 </span>            :    * enforces some symmetries in the results returned. */
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span><span class="lineCov">       2680 :   sincosdx(lat1, &amp;sbet1, &amp;cbet1); sbet1 *= g-&gt;f1;</span>
<span class="lineNum">     816 </span>            :   /* Ensure cbet1 = +epsilon at poles */
<span class="lineNum">     817 </span><span class="lineCov">       2680 :   norm2(&amp;sbet1, &amp;cbet1); cbet1 = maxx(tiny, cbet1);</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineCov">       2680 :   sincosdx(lat2, &amp;sbet2, &amp;cbet2); sbet2 *= g-&gt;f1;</span>
<span class="lineNum">     820 </span>            :   /* Ensure cbet2 = +epsilon at poles */
<span class="lineNum">     821 </span><span class="lineCov">       2680 :   norm2(&amp;sbet2, &amp;cbet2); cbet2 = maxx(tiny, cbet2);</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :   /* If cbet1 &lt; -sbet1, then cbet2 - cbet1 is a sensitive measure of the
<span class="lineNum">     824 </span>            :    * |bet1| - |bet2|.  Alternatively (cbet1 &gt;= -sbet1), abs(sbet2) + sbet1 is
<span class="lineNum">     825 </span>            :    * a better measure.  This logic is used in assigning calp2 in Lambda12.
<span class="lineNum">     826 </span>            :    * Sometimes these quantities vanish and in that case we force bet2 = +/-
<span class="lineNum">     827 </span>            :    * bet1 exactly.  An example where is is necessary is the inverse problem
<span class="lineNum">     828 </span>            :    * 48.522876735459 0 -48.52287673545898293 179.599720456223079643
<span class="lineNum">     829 </span>            :    * which failed with Visual Studio 10 (Release and Debug) */
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineCov">       2680 :   if (cbet1 &lt; -sbet1) {</span>
<span class="lineNum">     832 </span><span class="lineCov">        854 :     if (cbet2 == cbet1)</span>
<span class="lineNum">     833 </span><span class="lineCov">        186 :       sbet2 = sbet2 &lt; 0 ? sbet1 : -sbet1;</span>
<span class="lineNum">     834 </span>            :   } else {
<span class="lineNum">     835 </span><span class="lineCov">       1826 :     if (fabs(sbet2) == -sbet1)</span>
<span class="lineNum">     836 </span><span class="lineCov">        531 :       cbet2 = cbet1;</span>
<span class="lineNum">     837 </span>            :   }
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span><span class="lineCov">       2680 :   dn1 = sqrt(1 + g-&gt;ep2 * sq(sbet1));</span>
<span class="lineNum">     840 </span><span class="lineCov">       2680 :   dn2 = sqrt(1 + g-&gt;ep2 * sq(sbet2));</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineCov">       2680 :   meridian = lat1 == -90 || slam12 == 0;</span>
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span><span class="lineCov">       2680 :   if (meridian) {</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :     /* Endpoints are on a single full meridian, so the geodesic might lie on
<span class="lineNum">     847 </span>            :      * a meridian. */
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            :     real ssig1, csig1, ssig2, csig2;
<span class="lineNum">     850 </span><span class="lineCov">        775 :     calp1 = clam12; salp1 = slam12; /* Head to the target longitude */</span>
<span class="lineNum">     851 </span><span class="lineCov">        775 :     calp2 = 1; salp2 = 0;           /* At the target we're heading north */</span>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            :     /* tan(bet) = tan(sig) * cos(alp) */
<span class="lineNum">     854 </span><span class="lineCov">        775 :     ssig1 = sbet1; csig1 = calp1 * cbet1;</span>
<span class="lineNum">     855 </span><span class="lineCov">        775 :     ssig2 = sbet2; csig2 = calp2 * cbet2;</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :     /* sig12 = sig2 - sig1 */
<span class="lineNum">     858 </span><span class="lineCov">        775 :     sig12 = atan2(maxx((real)(0), csig1 * ssig2 - ssig1 * csig2),</span>
<span class="lineNum">     859 </span><span class="lineCov">        775 :                                   csig1 * csig2 + ssig1 * ssig2);</span>
<span class="lineNum">     860 </span><span class="lineCov">       1550 :     Lengths(g, g-&gt;n, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2,</span>
<span class="lineNum">     861 </span>            :             cbet1, cbet2, &amp;s12x, &amp;m12x, 0,
<span class="lineNum">     862 </span><span class="lineCov">        775 :             (outmask &amp; GEOD_GEODESICSCALE) ? &amp;M12 : 0,</span>
<span class="lineNum">     863 </span><span class="lineCov">        775 :             (outmask &amp; GEOD_GEODESICSCALE) ? &amp;M21 : 0,</span>
<span class="lineNum">     864 </span>            :             Ca);
<span class="lineNum">     865 </span>            :     /* Add the check for sig12 since zero length geodesics might yield m12 &lt;
<span class="lineNum">     866 </span>            :      * 0.  Test case was
<span class="lineNum">     867 </span>            :      *
<span class="lineNum">     868 </span>            :      *    echo 20.001 0 20.001 0 | GeodSolve -i
<span class="lineNum">     869 </span>            :      *
<span class="lineNum">     870 </span>            :      * In fact, we will have sig12 &gt; pi/2 for meridional geodesic which is
<span class="lineNum">     871 </span>            :      * not a shortest path. */
<span class="lineNum">     872 </span><span class="lineCov">        775 :     if (sig12 &lt; 1 || m12x &gt;= 0) {</span>
<span class="lineNum">     873 </span>            :       /* Need at least 2, to handle 90 0 90 180 */
<span class="lineNum">     874 </span><span class="lineCov">        766 :       if (sig12 &lt; 3 * tiny)</span>
<span class="lineNum">     875 </span><span class="lineCov">        177 :         sig12 = m12x = s12x = 0;</span>
<span class="lineNum">     876 </span><span class="lineCov">        766 :       m12x *= g-&gt;b;</span>
<span class="lineNum">     877 </span><span class="lineCov">        766 :       s12x *= g-&gt;b;</span>
<span class="lineNum">     878 </span><span class="lineCov">        766 :       a12 = sig12 / degree;</span>
<span class="lineNum">     879 </span>            :     } else
<span class="lineNum">     880 </span>            :       /* m12 &lt; 0, i.e., prolate and too close to anti-podal */
<span class="lineNum">     881 </span><span class="lineCov">          9 :       meridian = FALSE;</span>
<span class="lineNum">     882 </span>            :   }
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineCov">       4594 :   if (!meridian &amp;&amp;</span>
<span class="lineNum">     885 </span><span class="lineCov">       2150 :       sbet1 == 0 &amp;&amp;           /* and sbet2 == 0 */</span>
<span class="lineNum">     886 </span>            :       /* Mimic the way Lambda12 works with calp1 = 0 */
<span class="lineNum">     887 </span><span class="lineCov">        465 :       (g-&gt;f &lt;= 0 || lon12s &gt;= g-&gt;f * 180)) {</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :     /* Geodesic runs along equator */
<span class="lineNum">     890 </span><span class="lineCov">        234 :     calp1 = calp2 = 0; salp1 = salp2 = 1;</span>
<span class="lineNum">     891 </span><span class="lineCov">        234 :     s12x = g-&gt;a * lam12;</span>
<span class="lineNum">     892 </span><span class="lineCov">        234 :     sig12 = omg12 = lam12 / g-&gt;f1;</span>
<span class="lineNum">     893 </span><span class="lineCov">        234 :     m12x = g-&gt;b * sin(sig12);</span>
<span class="lineNum">     894 </span><span class="lineCov">        234 :     if (outmask &amp; GEOD_GEODESICSCALE)</span>
<span class="lineNum">     895 </span><span class="lineCov">          2 :       M12 = M21 = cos(sig12);</span>
<span class="lineNum">     896 </span><span class="lineCov">        234 :     a12 = lon12 / g-&gt;f1;</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineCov">       2446 :   } else if (!meridian) {</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :     /* Now point1 and point2 belong within a hemisphere bounded by a
<span class="lineNum">     901 </span>            :      * meridian and geodesic is neither meridional or equatorial. */
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :     /* Figure a starting point for Newton's method */
<span class="lineNum">     904 </span><span class="lineCov">       1680 :     real dnm = 0;</span>
<span class="lineNum">     905 </span><span class="lineCov">       1680 :     sig12 = InverseStart(g, sbet1, cbet1, dn1, sbet2, cbet2, dn2,</span>
<span class="lineNum">     906 </span>            :                          lam12, slam12, clam12,
<span class="lineNum">     907 </span>            :                          &amp;salp1, &amp;calp1, &amp;salp2, &amp;calp2, &amp;dnm,
<span class="lineNum">     908 </span>            :                          Ca);
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineCov">       1680 :     if (sig12 &gt;= 0) {</span>
<span class="lineNum">     911 </span>            :       /* Short lines (InverseStart sets salp2, calp2, dnm) */
<span class="lineNum">     912 </span><span class="lineCov">       1096 :       s12x = sig12 * g-&gt;b * dnm;</span>
<span class="lineNum">     913 </span><span class="lineCov">       1096 :       m12x = sq(dnm) * g-&gt;b * sin(sig12 / dnm);</span>
<span class="lineNum">     914 </span><span class="lineCov">       1096 :       if (outmask &amp; GEOD_GEODESICSCALE)</span>
<span class="lineNum">     915 </span><span class="lineCov">          2 :         M12 = M21 = cos(sig12 / dnm);</span>
<span class="lineNum">     916 </span><span class="lineCov">       1096 :       a12 = sig12 / degree;</span>
<span class="lineNum">     917 </span><span class="lineCov">       1096 :       omg12 = lam12 / (g-&gt;f1 * dnm);</span>
<span class="lineNum">     918 </span>            :     } else {
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :       /* Newton's method.  This is a straightforward solution of f(alp1) =
<span class="lineNum">     921 </span>            :        * lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one
<span class="lineNum">     922 </span>            :        * root in the interval (0, pi) and its derivative is positive at the
<span class="lineNum">     923 </span>            :        * root.  Thus f(alp) is positive for alp &gt; alp1 and negative for alp &lt;
<span class="lineNum">     924 </span>            :        * alp1.  During the course of the iteration, a range (alp1a, alp1b) is
<span class="lineNum">     925 </span>            :        * maintained which brackets the root and with each evaluation of
<span class="lineNum">     926 </span>            :        * f(alp) the range is shrunk, if possible.  Newton's method is
<span class="lineNum">     927 </span>            :        * restarted whenever the derivative of f is negative (because the new
<span class="lineNum">     928 </span>            :        * value of alp1 is then further from the solution) or if the new
<span class="lineNum">     929 </span>            :        * estimate of alp1 lies outside (0,pi); in this case, the new starting
<span class="lineNum">     930 </span>            :        * guess is taken to be (alp1a + alp1b) / 2. */
<span class="lineNum">     931 </span><span class="lineCov">        584 :       real ssig1 = 0, csig1 = 0, ssig2 = 0, csig2 = 0, eps = 0, domg12 = 0;</span>
<span class="lineNum">     932 </span><span class="lineCov">        584 :       unsigned numit = 0;</span>
<span class="lineNum">     933 </span>            :       /* Bracketing range */
<span class="lineNum">     934 </span><span class="lineCov">        584 :       real salp1a = tiny, calp1a = 1, salp1b = tiny, calp1b = -1;</span>
<span class="lineNum">     935 </span><span class="lineCov">        584 :       boolx tripn = FALSE;</span>
<span class="lineNum">     936 </span><span class="lineCov">        584 :       boolx tripb = FALSE;</span>
<span class="lineNum">     937 </span><span class="lineCov">       1986 :       for (; numit &lt; maxit2; ++numit) {</span>
<span class="lineNum">     938 </span>            :         /* the WGS84 test set: mean = 1.47, sd = 1.25, max = 16
<span class="lineNum">     939 </span>            :          * WGS84 and random input: mean = 2.85, sd = 0.60 */
<span class="lineNum">     940 </span><span class="lineCov">       1986 :         real dv = 0,</span>
<span class="lineNum">     941 </span><span class="lineCov">       1986 :           v = Lambda12(g, sbet1, cbet1, dn1, sbet2, cbet2, dn2, salp1, calp1,</span>
<span class="lineNum">     942 </span>            :                         slam12, clam12,
<span class="lineNum">     943 </span>            :                         &amp;salp2, &amp;calp2, &amp;sig12, &amp;ssig1, &amp;csig1, &amp;ssig2, &amp;csig2,
<span class="lineNum">     944 </span>            :                         &amp;eps, &amp;domg12, numit &lt; maxit1, &amp;dv, Ca);
<span class="lineNum">     945 </span>            :         /* 2 * tol0 is approximately 1 ulp for a number in [0, pi]. */
<span class="lineNum">     946 </span>            :         /* Reversed test to allow escape with NaNs */
<span class="lineNum">     947 </span><span class="lineCov">       1986 :         if (tripb || !(fabs(v) &gt;= (tripn ? 8 : 1) * tol0)) break;</span>
<span class="lineNum">     948 </span>            :         /* Update bracketing values */
<span class="lineNum">     949 </span><span class="lineCov">       1402 :         if (v &gt; 0 &amp;&amp; (numit &gt; maxit1 || calp1/salp1 &gt; calp1b/salp1b))</span>
<span class="lineNum">     950 </span><span class="lineCov">        494 :           { salp1b = salp1; calp1b = calp1; }</span>
<span class="lineNum">     951 </span><span class="lineCov">        908 :         else if (v &lt; 0 &amp;&amp; (numit &gt; maxit1 || calp1/salp1 &lt; calp1a/salp1a))</span>
<span class="lineNum">     952 </span><span class="lineCov">        908 :           { salp1a = salp1; calp1a = calp1; }</span>
<span class="lineNum">     953 </span><span class="lineCov">       1402 :         if (numit &lt; maxit1 &amp;&amp; dv &gt; 0) {</span>
<span class="lineNum">     954 </span>            :           real
<span class="lineNum">     955 </span><span class="lineCov">       1400 :             dalp1 = -v/dv;</span>
<span class="lineNum">     956 </span>            :           real
<span class="lineNum">     957 </span><span class="lineCov">       1400 :             sdalp1 = sin(dalp1), cdalp1 = cos(dalp1),</span>
<span class="lineNum">     958 </span><span class="lineCov">       1400 :             nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;</span>
<span class="lineNum">     959 </span><span class="lineCov">       1400 :           if (nsalp1 &gt; 0 &amp;&amp; fabs(dalp1) &lt; pi) {</span>
<span class="lineNum">     960 </span><span class="lineCov">       1400 :             calp1 = calp1 * cdalp1 - salp1 * sdalp1;</span>
<span class="lineNum">     961 </span><span class="lineCov">       1400 :             salp1 = nsalp1;</span>
<span class="lineNum">     962 </span><span class="lineCov">       1400 :             norm2(&amp;salp1, &amp;calp1);</span>
<span class="lineNum">     963 </span>            :             /* In some regimes we don't get quadratic convergence because
<span class="lineNum">     964 </span>            :              * slope -&gt; 0.  So use convergence conditions based on epsilon
<span class="lineNum">     965 </span>            :              * instead of sqrt(epsilon). */
<span class="lineNum">     966 </span><span class="lineCov">       1400 :             tripn = fabs(v) &lt;= 16 * tol0;</span>
<span class="lineNum">     967 </span><span class="lineCov">       1400 :             continue;</span>
<span class="lineNum">     968 </span>            :           }
<span class="lineNum">     969 </span>            :         }
<span class="lineNum">     970 </span>            :         /* Either dv was not positive or updated value was outside legal
<span class="lineNum">     971 </span>            :          * range.  Use the midpoint of the bracket as the next estimate.
<span class="lineNum">     972 </span>            :          * This mechanism is not needed for the WGS84 ellipsoid, but it does
<span class="lineNum">     973 </span>            :          * catch problems with more eccentric ellipsoids.  Its efficacy is
<span class="lineNum">     974 </span>            :          * such for the WGS84 test set with the starting guess set to alp1 =
<span class="lineNum">     975 </span>            :          * 90deg:
<span class="lineNum">     976 </span>            :          * the WGS84 test set: mean = 5.21, sd = 3.93, max = 24
<span class="lineNum">     977 </span>            :          * WGS84 and random input: mean = 4.74, sd = 0.99 */
<span class="lineNum">     978 </span><span class="lineCov">          2 :         salp1 = (salp1a + salp1b)/2;</span>
<span class="lineNum">     979 </span><span class="lineCov">          2 :         calp1 = (calp1a + calp1b)/2;</span>
<span class="lineNum">     980 </span><span class="lineCov">          2 :         norm2(&amp;salp1, &amp;calp1);</span>
<span class="lineNum">     981 </span><span class="lineCov">          2 :         tripn = FALSE;</span>
<span class="lineNum">     982 </span><span class="lineCov">          4 :         tripb = (fabs(salp1a - salp1) + (calp1a - calp1) &lt; tolb ||</span>
<span class="lineNum">     983 </span><span class="lineCov">          2 :                  fabs(salp1 - salp1b) + (calp1 - calp1b) &lt; tolb);</span>
<span class="lineNum">     984 </span>            :       }
<span class="lineNum">     985 </span><span class="lineCov">       1168 :       Lengths(g, eps, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2,</span>
<span class="lineNum">     986 </span>            :               cbet1, cbet2, &amp;s12x, &amp;m12x, 0,
<span class="lineNum">     987 </span><span class="lineCov">        584 :               (outmask &amp; GEOD_GEODESICSCALE) ? &amp;M12 : 0,</span>
<span class="lineNum">     988 </span><span class="lineCov">        584 :               (outmask &amp; GEOD_GEODESICSCALE) ? &amp;M21 : 0, Ca);</span>
<span class="lineNum">     989 </span><span class="lineCov">        584 :       m12x *= g-&gt;b;</span>
<span class="lineNum">     990 </span><span class="lineCov">        584 :       s12x *= g-&gt;b;</span>
<span class="lineNum">     991 </span><span class="lineCov">        584 :       a12 = sig12 / degree;</span>
<span class="lineNum">     992 </span><span class="lineCov">        584 :       if (outmask &amp; GEOD_AREA) {</span>
<span class="lineNum">     993 </span>            :         /* omg12 = lam12 - domg12 */
<span class="lineNum">     994 </span><span class="lineCov">        224 :         real sdomg12 = sin(domg12), cdomg12 = cos(domg12);</span>
<span class="lineNum">     995 </span><span class="lineCov">        224 :         somg12 = slam12 * cdomg12 - clam12 * sdomg12;</span>
<span class="lineNum">     996 </span><span class="lineCov">        224 :         comg12 = clam12 * cdomg12 + slam12 * sdomg12;</span>
<span class="lineNum">     997 </span>            :       }
<span class="lineNum">     998 </span>            :     }
<span class="lineNum">     999 </span>            :   }
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span><span class="lineCov">       2680 :   if (outmask &amp; GEOD_DISTANCE)</span>
<span class="lineNum">    1002 </span><span class="lineCov">       2668 :     s12 = 0 + s12x;             /* Convert -0 to 0 */</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span><span class="lineCov">       2680 :   if (outmask &amp; GEOD_REDUCEDLENGTH)</span>
<span class="lineNum">    1005 </span><span class="lineCov">         46 :     m12 = 0 + m12x;             /* Convert -0 to 0 */</span>
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineCov">       2680 :   if (outmask &amp; GEOD_AREA) {</span>
<span class="lineNum">    1008 </span>            :     real
<span class="lineNum">    1009 </span>            :       /* From Lambda12: sin(alp1) * cos(bet1) = sin(alp0) */
<span class="lineNum">    1010 </span><span class="lineCov">        254 :       salp0 = salp1 * cbet1,</span>
<span class="lineNum">    1011 </span><span class="lineCov">        254 :       calp0 = hypotx(calp1, salp1 * sbet1); /* calp0 &gt; 0 */</span>
<span class="lineNum">    1012 </span>            :     real alp12;
<span class="lineNum">    1013 </span><span class="lineCov">        488 :     if (calp0 != 0 &amp;&amp; salp0 != 0) {</span>
<span class="lineNum">    1014 </span>            :       real
<span class="lineNum">    1015 </span>            :         /* From Lambda12: tan(bet) = tan(sig) * cos(alp) */
<span class="lineNum">    1016 </span><span class="lineCov">        234 :         ssig1 = sbet1, csig1 = calp1 * cbet1,</span>
<span class="lineNum">    1017 </span><span class="lineCov">        234 :         ssig2 = sbet2, csig2 = calp2 * cbet2,</span>
<span class="lineNum">    1018 </span><span class="lineCov">        234 :         k2 = sq(calp0) * g-&gt;ep2,</span>
<span class="lineNum">    1019 </span><span class="lineCov">        234 :         eps = k2 / (2 * (1 + sqrt(1 + k2)) + k2),</span>
<span class="lineNum">    1020 </span>            :         /* Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0). */
<span class="lineNum">    1021 </span><span class="lineCov">        234 :         A4 = sq(g-&gt;a) * calp0 * salp0 * g-&gt;e2;</span>
<span class="lineNum">    1022 </span>            :       real B41, B42;
<span class="lineNum">    1023 </span><span class="lineCov">        234 :       norm2(&amp;ssig1, &amp;csig1);</span>
<span class="lineNum">    1024 </span><span class="lineCov">        234 :       norm2(&amp;ssig2, &amp;csig2);</span>
<span class="lineNum">    1025 </span><span class="lineCov">        234 :       C4f(g, eps, Ca);</span>
<span class="lineNum">    1026 </span><span class="lineCov">        234 :       B41 = SinCosSeries(FALSE, ssig1, csig1, Ca, nC4);</span>
<span class="lineNum">    1027 </span><span class="lineCov">        234 :       B42 = SinCosSeries(FALSE, ssig2, csig2, Ca, nC4);</span>
<span class="lineNum">    1028 </span><span class="lineCov">        234 :       S12 = A4 * (B42 - B41);</span>
<span class="lineNum">    1029 </span>            :     } else
<span class="lineNum">    1030 </span>            :       /* Avoid problems with indeterminate sig1, sig2 on equator */
<span class="lineNum">    1031 </span><span class="lineCov">         20 :       S12 = 0;</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineCov">        254 :     if (!meridian &amp;&amp; somg12 &gt; 1) {</span>
<span class="lineNum">    1034 </span><span class="lineCov">         10 :       somg12 = sin(omg12); comg12 = cos(omg12);</span>
<span class="lineNum">    1035 </span>            :     }
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineCov">        254 :     if (!meridian &amp;&amp;</span>
<span class="lineNum">    1038 </span>            :         /* omg12 &lt; 3/4 * pi */
<span class="lineNum">    1039 </span><span class="lineCov">        212 :         comg12 &gt; -(real)(0.7071) &amp;&amp;     /* Long difference not too big */</span>
<span class="lineNum">    1040 </span><span class="lineCov">        422 :         sbet2 - sbet1 &lt; (real)(1.75)) { /* Lat difference not too big */</span>
<span class="lineNum">    1041 </span>            :       /* Use tan(Gamma/2) = tan(omg12/2)
<span class="lineNum">    1042 </span>            :        * * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))
<span class="lineNum">    1043 </span>            :        * with tan(x/2) = sin(x)/(1+cos(x)) */
<span class="lineNum">    1044 </span>            :       real
<span class="lineNum">    1045 </span><span class="lineCov">        210 :         domg12 = 1 + comg12, dbet1 = 1 + cbet1, dbet2 = 1 + cbet2;</span>
<span class="lineNum">    1046 </span><span class="lineCov">        210 :       alp12 = 2 * atan2( somg12 * ( sbet1 * dbet2 + sbet2 * dbet1 ),</span>
<span class="lineNum">    1047 </span><span class="lineCov">        210 :                          domg12 * ( sbet1 * sbet2 + dbet1 * dbet2 ) );</span>
<span class="lineNum">    1048 </span>            :     } else {
<span class="lineNum">    1049 </span>            :       /* alp12 = alp2 - alp1, used in atan2 so no need to normalize */
<span class="lineNum">    1050 </span>            :       real
<span class="lineNum">    1051 </span><span class="lineCov">         44 :         salp12 = salp2 * calp1 - calp2 * salp1,</span>
<span class="lineNum">    1052 </span><span class="lineCov">         44 :         calp12 = calp2 * calp1 + salp2 * salp1;</span>
<span class="lineNum">    1053 </span>            :       /* The right thing appears to happen if alp1 = +/-180 and alp2 = 0, viz
<span class="lineNum">    1054 </span>            :        * salp12 = -0 and alp12 = -180.  However this depends on the sign
<span class="lineNum">    1055 </span>            :        * being attached to 0 correctly.  The following ensures the correct
<span class="lineNum">    1056 </span>            :        * behavior. */
<span class="lineNum">    1057 </span><span class="lineCov">         44 :       if (salp12 == 0 &amp;&amp; calp12 &lt; 0) {</span>
<span class="lineNum">    1058 </span><span class="lineCov">         14 :         salp12 = tiny * calp1;</span>
<span class="lineNum">    1059 </span><span class="lineCov">         14 :         calp12 = -1;</span>
<span class="lineNum">    1060 </span>            :       }
<span class="lineNum">    1061 </span><span class="lineCov">         44 :       alp12 = atan2(salp12, calp12);</span>
<span class="lineNum">    1062 </span>            :     }
<span class="lineNum">    1063 </span><span class="lineCov">        254 :     S12 += g-&gt;c2 * alp12;</span>
<span class="lineNum">    1064 </span><span class="lineCov">        254 :     S12 *= swapp * lonsign * latsign;</span>
<span class="lineNum">    1065 </span>            :     /* Convert -0 to 0 */
<span class="lineNum">    1066 </span><span class="lineCov">        254 :     S12 += 0;</span>
<span class="lineNum">    1067 </span>            :   }
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            :   /* Convert calp, salp to azimuth accounting for lonsign, swapp, latsign. */
<span class="lineNum">    1070 </span><span class="lineCov">       2680 :   if (swapp &lt; 0) {</span>
<span class="lineNum">    1071 </span><span class="lineCov">        996 :     swapx(&amp;salp1, &amp;salp2);</span>
<span class="lineNum">    1072 </span><span class="lineCov">        996 :     swapx(&amp;calp1, &amp;calp2);</span>
<span class="lineNum">    1073 </span><span class="lineCov">        996 :     if (outmask &amp; GEOD_GEODESICSCALE)</span>
<span class="lineNum">    1074 </span><span class="lineCov">         18 :       swapx(&amp;M12, &amp;M21);</span>
<span class="lineNum">    1075 </span>            :   }
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineCov">       2680 :   salp1 *= swapp * lonsign; calp1 *= swapp * latsign;</span>
<span class="lineNum">    1078 </span><span class="lineCov">       2680 :   salp2 *= swapp * lonsign; calp2 *= swapp * latsign;</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineCov">       2680 :   if (psalp1) *psalp1 = salp1;</span>
<span class="lineNum">    1081 </span><span class="lineCov">       2680 :   if (pcalp1) *pcalp1 = calp1;</span>
<span class="lineNum">    1082 </span><span class="lineCov">       2680 :   if (psalp2) *psalp2 = salp2;</span>
<span class="lineNum">    1083 </span><span class="lineCov">       2680 :   if (pcalp2) *pcalp2 = calp2;</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span><span class="lineCov">       2680 :   if (outmask &amp; GEOD_DISTANCE)</span>
<span class="lineNum">    1086 </span><span class="lineCov">       2668 :     *ps12 = s12;</span>
<span class="lineNum">    1087 </span><span class="lineCov">       2680 :   if (outmask &amp; GEOD_REDUCEDLENGTH)</span>
<span class="lineNum">    1088 </span><span class="lineCov">         46 :     *pm12 = m12;</span>
<span class="lineNum">    1089 </span><span class="lineCov">       2680 :   if (outmask &amp; GEOD_GEODESICSCALE) {</span>
<span class="lineNum">    1090 </span><span class="lineCov">         50 :     if (pM12) *pM12 = M12;</span>
<span class="lineNum">    1091 </span><span class="lineCov">         50 :     if (pM21) *pM21 = M21;</span>
<span class="lineNum">    1092 </span>            :   }
<span class="lineNum">    1093 </span><span class="lineCov">       2680 :   if (outmask &amp; GEOD_AREA)</span>
<span class="lineNum">    1094 </span><span class="lineCov">        254 :     *pS12 = S12;</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :   /* Returned value in [0, 180] */
<span class="lineNum">    1097 </span><span class="lineCov">       2680 :   return a12;</span>
<a name="1098"><span class="lineNum">    1098 </span>            : }</a>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span><span class="lineCov">       2674 : real geod_geninverse(const struct geod_geodesic* g,</span>
<span class="lineNum">    1101 </span>            :                      real lat1, real lon1, real lat2, real lon2,
<span class="lineNum">    1102 </span>            :                      real* ps12, real* pazi1, real* pazi2,
<span class="lineNum">    1103 </span>            :                      real* pm12, real* pM12, real* pM21, real* pS12) {
<span class="lineNum">    1104 </span>            :   real salp1, calp1, salp2, calp2,
<span class="lineNum">    1105 </span><span class="lineCov">       2674 :     a12 = geod_geninverse_int(g, lat1, lon1, lat2, lon2, ps12,</span>
<span class="lineNum">    1106 </span>            :                               &amp;salp1, &amp;calp1, &amp;salp2, &amp;calp2,
<span class="lineNum">    1107 </span>            :                               pm12, pM12, pM21, pS12);
<span class="lineNum">    1108 </span><span class="lineCov">       2674 :   if (pazi1) *pazi1 = atan2dx(salp1, calp1);</span>
<span class="lineNum">    1109 </span><span class="lineCov">       2674 :   if (pazi2) *pazi2 = atan2dx(salp2, calp2);</span>
<span class="lineNum">    1110 </span><span class="lineCov">       2674 :   return a12;</span>
<a name="1111"><span class="lineNum">    1111 </span>            : }</a>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineCov">          6 : void geod_inverseline(struct geod_geodesicline* l,</span>
<span class="lineNum">    1114 </span>            :                       const struct geod_geodesic* g,
<span class="lineNum">    1115 </span>            :                       real lat1, real lon1, real lat2, real lon2,
<span class="lineNum">    1116 </span>            :                       unsigned caps) {
<span class="lineNum">    1117 </span>            :   real salp1, calp1,
<span class="lineNum">    1118 </span><span class="lineCov">          6 :     a12 = geod_geninverse_int(g, lat1, lon1, lat2, lon2, 0,</span>
<span class="lineNum">    1119 </span>            :                               &amp;salp1, &amp;calp1, 0, 0,
<span class="lineNum">    1120 </span>            :                               0, 0, 0, 0),
<span class="lineNum">    1121 </span><span class="lineCov">          6 :     azi1 = atan2dx(salp1, calp1);</span>
<span class="lineNum">    1122 </span><span class="lineCov">          6 :   caps = caps ? caps : GEOD_DISTANCE_IN | GEOD_LONGITUDE;</span>
<span class="lineNum">    1123 </span>            :   /* Ensure that a12 can be converted to a distance */
<span class="lineNum">    1124 </span><span class="lineCov">          6 :   if (caps &amp; (OUT_ALL &amp; GEOD_DISTANCE_IN)) caps |= GEOD_DISTANCE;</span>
<span class="lineNum">    1125 </span><span class="lineCov">          6 :   geod_lineinit_int(l, g, lat1, lon1, azi1, salp1, calp1, caps);</span>
<span class="lineNum">    1126 </span><span class="lineCov">          6 :   geod_setarc(l, a12);</span>
<a name="1127"><span class="lineNum">    1127 </span><span class="lineCov">          6 : }</span></a>
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span><span class="lineCov">       2410 : void geod_inverse(const struct geod_geodesic* g,</span>
<span class="lineNum">    1130 </span>            :                   real lat1, real lon1, real lat2, real lon2,
<span class="lineNum">    1131 </span>            :                   real* ps12, real* pazi1, real* pazi2) {
<span class="lineNum">    1132 </span><span class="lineCov">       2410 :   geod_geninverse(g, lat1, lon1, lat2, lon2, ps12, pazi1, pazi2, 0, 0, 0, 0);</span>
<a name="1133"><span class="lineNum">    1133 </span><span class="lineCov">       2410 : }</span></a>
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span><span class="lineCov">      18390 : real SinCosSeries(boolx sinp, real sinx, real cosx, const real c[], int n) {</span>
<span class="lineNum">    1136 </span>            :   /* Evaluate
<span class="lineNum">    1137 </span>            :    * y = sinp ? sum(c[i] * sin( 2*i    * x), i, 1, n) :
<span class="lineNum">    1138 </span>            :    *            sum(c[i] * cos((2*i+1) * x), i, 0, n-1)
<span class="lineNum">    1139 </span>            :    * using Clenshaw summation.  N.B. c[0] is unused for sin series
<span class="lineNum">    1140 </span>            :    * Approx operation count = (n + 5) mult and (2 * n + 2) add */
<span class="lineNum">    1141 </span>            :   real ar, y0, y1;
<span class="lineNum">    1142 </span><span class="lineCov">      18390 :   c += (n + sinp);              /* Point to one beyond last element */</span>
<span class="lineNum">    1143 </span><span class="lineCov">      18390 :   ar = 2 * (cosx - sinx) * (cosx + sinx); /* 2 * cos(2 * x) */</span>
<span class="lineNum">    1144 </span><span class="lineCov">      18390 :   y0 = (n &amp; 1) ? *--c : 0; y1 = 0;        /* accumulators for sum */</span>
<span class="lineNum">    1145 </span>            :   /* Now n is even */
<span class="lineNum">    1146 </span><span class="lineCov">      18390 :   n /= 2;</span>
<span class="lineNum">    1147 </span><span class="lineCov">      85908 :   while (n--) {</span>
<span class="lineNum">    1148 </span>            :     /* Unroll loop x 2, so accumulators return to their original role */
<span class="lineNum">    1149 </span><span class="lineCov">      49128 :     y1 = ar * y0 - y1 + *--c;</span>
<span class="lineNum">    1150 </span><span class="lineCov">      49128 :     y0 = ar * y1 - y0 + *--c;</span>
<span class="lineNum">    1151 </span>            :   }
<span class="lineNum">    1152 </span><span class="lineCov">      18390 :   return sinp</span>
<span class="lineNum">    1153 </span><span class="lineCov">      17692 :     ? 2 * sinx * cosx * y0      /* sin(2 * x) * y0 */</span>
<span class="lineNum">    1154 </span><span class="lineCov">      36082 :     : cosx * (y0 - y1);         /* cos(x) * (y0 - y1) */</span>
<a name="1155"><span class="lineNum">    1155 </span>            : }</a>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineCov">       3339 : void Lengths(const struct geod_geodesic* g,</span>
<span class="lineNum">    1158 </span>            :              real eps, real sig12,
<span class="lineNum">    1159 </span>            :              real ssig1, real csig1, real dn1,
<span class="lineNum">    1160 </span>            :              real ssig2, real csig2, real dn2,
<span class="lineNum">    1161 </span>            :              real cbet1, real cbet2,
<span class="lineNum">    1162 </span>            :              real* ps12b, real* pm12b, real* pm0,
<span class="lineNum">    1163 </span>            :              real* pM12, real* pM21,
<span class="lineNum">    1164 </span>            :              /* Scratch area of the right size */
<span class="lineNum">    1165 </span>            :              real Ca[]) {
<span class="lineNum">    1166 </span><span class="lineCov">       3339 :   real m0 = 0, J12 = 0, A1 = 0, A2 = 0;</span>
<span class="lineNum">    1167 </span>            :   real Cb[nC];
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            :   /* Return m12b = (reduced length)/b; also calculate s12b = distance/b,
<span class="lineNum">    1170 </span>            :    * and m0 = coefficient of secular term in expression for reduced length. */
<span class="lineNum">    1171 </span><span class="lineCov">       3339 :   boolx redlp = pm12b || pm0 || pM12 || pM21;</span>
<span class="lineNum">    1172 </span><span class="lineCov">       3339 :   if (ps12b || redlp) {</span>
<span class="lineNum">    1173 </span><span class="lineCov">       3339 :     A1 = A1m1f(eps);</span>
<span class="lineNum">    1174 </span><span class="lineCov">       3339 :     C1f(eps, Ca);</span>
<span class="lineNum">    1175 </span><span class="lineCov">       3339 :     if (redlp) {</span>
<span class="lineNum">    1176 </span><span class="lineCov">       3339 :       A2 = A2m1f(eps);</span>
<span class="lineNum">    1177 </span><span class="lineCov">       3339 :       C2f(eps, Cb);</span>
<span class="lineNum">    1178 </span><span class="lineCov">       3339 :       m0 = A1 - A2;</span>
<span class="lineNum">    1179 </span><span class="lineCov">       3339 :       A2 = 1 + A2;</span>
<span class="lineNum">    1180 </span>            :     }
<span class="lineNum">    1181 </span><span class="lineCov">       3339 :     A1 = 1 + A1;</span>
<span class="lineNum">    1182 </span>            :   }
<span class="lineNum">    1183 </span><span class="lineCov">       3339 :   if (ps12b) {</span>
<span class="lineNum">    1184 </span><span class="lineCov">       2718 :     real B1 = SinCosSeries(TRUE, ssig2, csig2, Ca, nC1) -</span>
<span class="lineNum">    1185 </span><span class="lineCov">       1359 :       SinCosSeries(TRUE, ssig1, csig1, Ca, nC1);</span>
<span class="lineNum">    1186 </span>            :     /* Missing a factor of b */
<span class="lineNum">    1187 </span><span class="lineCov">       1359 :     *ps12b = A1 * (sig12 + B1);</span>
<span class="lineNum">    1188 </span><span class="lineCov">       1359 :     if (redlp) {</span>
<span class="lineNum">    1189 </span><span class="lineCov">       2718 :       real B2 = SinCosSeries(TRUE, ssig2, csig2, Cb, nC2) -</span>
<span class="lineNum">    1190 </span><span class="lineCov">       1359 :         SinCosSeries(TRUE, ssig1, csig1, Cb, nC2);</span>
<span class="lineNum">    1191 </span><span class="lineCov">       1359 :       J12 = m0 * sig12 + (A1 * B1 - A2 * B2);</span>
<span class="lineNum">    1192 </span>            :     }
<span class="lineNum">    1193 </span><span class="lineCov">       1980 :   } else if (redlp) {</span>
<span class="lineNum">    1194 </span>            :     /* Assume here that nC1 &gt;= nC2 */
<span class="lineNum">    1195 </span>            :     int l;
<span class="lineNum">    1196 </span><span class="lineCov">      13860 :     for (l = 1; l &lt;= nC2; ++l)</span>
<span class="lineNum">    1197 </span><span class="lineCov">      11880 :       Cb[l] = A1 * Ca[l] - A2 * Cb[l];</span>
<span class="lineNum">    1198 </span><span class="lineCov">       3960 :     J12 = m0 * sig12 + (SinCosSeries(TRUE, ssig2, csig2, Cb, nC2) -</span>
<span class="lineNum">    1199 </span><span class="lineCov">       1980 :                         SinCosSeries(TRUE, ssig1, csig1, Cb, nC2));</span>
<span class="lineNum">    1200 </span>            :   }
<span class="lineNum">    1201 </span><span class="lineCov">       3339 :   if (pm0) *pm0 = m0;</span>
<span class="lineNum">    1202 </span><span class="lineCov">       3339 :   if (pm12b)</span>
<span class="lineNum">    1203 </span>            :     /* Missing a factor of b.
<span class="lineNum">    1204 </span>            :      * Add parens around (csig1 * ssig2) and (ssig1 * csig2) to ensure
<span class="lineNum">    1205 </span>            :      * accurate cancellation in the case of coincident points. */
<span class="lineNum">    1206 </span><span class="lineCov">       6678 :     *pm12b = dn2 * (csig1 * ssig2) - dn1 * (ssig1 * csig2) -</span>
<span class="lineNum">    1207 </span><span class="lineCov">       3339 :       csig1 * csig2 * J12;</span>
<span class="lineNum">    1208 </span><span class="lineCov">       3339 :   if (pM12 || pM21) {</span>
<span class="lineNum">    1209 </span><span class="lineCov">         46 :     real csig12 = csig1 * csig2 + ssig1 * ssig2;</span>
<span class="lineNum">    1210 </span><span class="lineCov">         46 :     real t = g-&gt;ep2 * (cbet1 - cbet2) * (cbet1 + cbet2) / (dn1 + dn2);</span>
<span class="lineNum">    1211 </span><span class="lineCov">         46 :     if (pM12)</span>
<span class="lineNum">    1212 </span><span class="lineCov">         46 :       *pM12 = csig12 + (t * ssig2 - csig2 * J12) * ssig1 / dn1;</span>
<span class="lineNum">    1213 </span><span class="lineCov">         46 :     if (pM21)</span>
<span class="lineNum">    1214 </span><span class="lineCov">         46 :       *pM21 = csig12 - (t * ssig1 - csig1 * J12) * ssig2 / dn2;</span>
<span class="lineNum">    1215 </span>            :   }
<a name="1216"><span class="lineNum">    1216 </span><span class="lineCov">       3339 : }</span></a>
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span><span class="lineCov">         17 : real Astroid(real x, real y) {</span>
<span class="lineNum">    1219 </span>            :   /* Solve k^4+2*k^3-(x^2+y^2-1)*k^2-2*y^2*k-y^2 = 0 for positive root k.
<span class="lineNum">    1220 </span>            :    * This solution is adapted from Geocentric::Reverse. */
<span class="lineNum">    1221 </span>            :   real k;
<span class="lineNum">    1222 </span>            :   real
<span class="lineNum">    1223 </span><span class="lineCov">         17 :     p = sq(x),</span>
<span class="lineNum">    1224 </span><span class="lineCov">         17 :     q = sq(y),</span>
<span class="lineNum">    1225 </span><span class="lineCov">         17 :     r = (p + q - 1) / 6;</span>
<span class="lineNum">    1226 </span><span class="lineCov">         34 :   if ( !(q == 0 &amp;&amp; r &lt;= 0) ) {</span>
<span class="lineNum">    1227 </span>            :     real
<span class="lineNum">    1228 </span>            :       /* Avoid possible division by zero when r = 0 by multiplying equations
<span class="lineNum">    1229 </span>            :        * for s and t by r^3 and r, resp. */
<span class="lineNum">    1230 </span><span class="lineCov">         17 :       S = p * q / 4,            /* S = r^3 * s */</span>
<span class="lineNum">    1231 </span><span class="lineCov">         17 :       r2 = sq(r),</span>
<span class="lineNum">    1232 </span><span class="lineCov">         17 :       r3 = r * r2,</span>
<span class="lineNum">    1233 </span>            :       /* The discriminant of the quadratic equation for T3.  This is zero on
<span class="lineNum">    1234 </span>            :        * the evolute curve p^(1/3)+q^(1/3) = 1 */
<span class="lineNum">    1235 </span><span class="lineCov">         17 :       disc = S * (S + 2 * r3);</span>
<span class="lineNum">    1236 </span><span class="lineCov">         17 :     real u = r;</span>
<span class="lineNum">    1237 </span>            :     real v, uv, w;
<span class="lineNum">    1238 </span><span class="lineCov">         17 :     if (disc &gt;= 0) {</span>
<span class="lineNum">    1239 </span><span class="lineCov">          4 :       real T3 = S + r3, T;</span>
<span class="lineNum">    1240 </span>            :       /* Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss
<span class="lineNum">    1241 </span>            :        * of precision due to cancellation.  The result is unchanged because
<span class="lineNum">    1242 </span>            :        * of the way the T is used in definition of u. */
<span class="lineNum">    1243 </span><span class="lineCov">          4 :       T3 += T3 &lt; 0 ? -sqrt(disc) : sqrt(disc); /* T3 = (r * t)^3 */</span>
<span class="lineNum">    1244 </span>            :       /* N.B. cbrtx always returns the real root.  cbrtx(-8) = -2. */
<span class="lineNum">    1245 </span><span class="lineCov">          4 :       T = cbrtx(T3);            /* T = r * t */</span>
<span class="lineNum">    1246 </span>            :       /* T can be zero; but then r2 / T -&gt; 0. */
<span class="lineNum">    1247 </span><span class="lineCov">          4 :       u += T + (T != 0 ? r2 / T : 0);</span>
<span class="lineNum">    1248 </span>            :     } else {
<span class="lineNum">    1249 </span>            :       /* T is complex, but the way u is defined the result is real. */
<span class="lineNum">    1250 </span><span class="lineCov">         13 :       real ang = atan2(sqrt(-disc), -(S + r3));</span>
<span class="lineNum">    1251 </span>            :       /* There are three possible cube roots.  We choose the root which
<span class="lineNum">    1252 </span>            :        * avoids cancellation.  Note that disc &lt; 0 implies that r &lt; 0. */
<span class="lineNum">    1253 </span><span class="lineCov">         13 :       u += 2 * r * cos(ang / 3);</span>
<span class="lineNum">    1254 </span>            :     }
<span class="lineNum">    1255 </span><span class="lineCov">         17 :     v = sqrt(sq(u) + q);              /* guaranteed positive */</span>
<span class="lineNum">    1256 </span>            :     /* Avoid loss of accuracy when u &lt; 0. */
<span class="lineNum">    1257 </span><span class="lineCov">         17 :     uv = u &lt; 0 ? q / (v - u) : u + v; /* u+v, guaranteed positive */</span>
<span class="lineNum">    1258 </span><span class="lineCov">         17 :     w = (uv - q) / (2 * v);           /* positive? */</span>
<span class="lineNum">    1259 </span>            :     /* Rearrange expression for k to avoid loss of accuracy due to
<span class="lineNum">    1260 </span>            :      * subtraction.  Division by 0 not possible because uv &gt; 0, w &gt;= 0. */
<span class="lineNum">    1261 </span><span class="lineCov">         17 :     k = uv / (sqrt(uv + sq(w)) + w);   /* guaranteed positive */</span>
<span class="lineNum">    1262 </span>            :   } else {               /* q == 0 &amp;&amp; r &lt;= 0 */
<span class="lineNum">    1263 </span>            :     /* y = 0 with |x| &lt;= 1.  Handle this case directly.
<span class="lineNum">    1264 </span>            :      * for y small, positive root is k = abs(y)/sqrt(1-x^2) */
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     k = 0;</span>
<span class="lineNum">    1266 </span>            :   }
<span class="lineNum">    1267 </span><span class="lineCov">         17 :   return k;</span>
<a name="1268"><span class="lineNum">    1268 </span>            : }</a>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineCov">       1680 : real InverseStart(const struct geod_geodesic* g,</span>
<span class="lineNum">    1271 </span>            :                   real sbet1, real cbet1, real dn1,
<span class="lineNum">    1272 </span>            :                   real sbet2, real cbet2, real dn2,
<span class="lineNum">    1273 </span>            :                   real lam12, real slam12, real clam12,
<span class="lineNum">    1274 </span>            :                   real* psalp1, real* pcalp1,
<span class="lineNum">    1275 </span>            :                   /* Only updated if return val &gt;= 0 */
<span class="lineNum">    1276 </span>            :                   real* psalp2, real* pcalp2,
<span class="lineNum">    1277 </span>            :                   /* Only updated for short lines */
<span class="lineNum">    1278 </span>            :                   real* pdnm,
<span class="lineNum">    1279 </span>            :                   /* Scratch area of the right size */
<span class="lineNum">    1280 </span>            :                   real Ca[]) {
<span class="lineNum">    1281 </span><span class="lineCov">       1680 :   real salp1 = 0, calp1 = 0, salp2 = 0, calp2 = 0, dnm = 0;</span>
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :   /* Return a starting point for Newton's method in salp1 and calp1 (function
<span class="lineNum">    1284 </span>            :    * value is -1).  If Newton's method doesn't need to be used, return also
<span class="lineNum">    1285 </span>            :    * salp2 and calp2 and function value is sig12. */
<span class="lineNum">    1286 </span>            :   real
<span class="lineNum">    1287 </span><span class="lineCov">       1680 :     sig12 = -1,               /* Return value */</span>
<span class="lineNum">    1288 </span>            :     /* bet12 = bet2 - bet1 in [0, pi); bet12a = bet2 + bet1 in (-pi, 0] */
<span class="lineNum">    1289 </span><span class="lineCov">       1680 :     sbet12 = sbet2 * cbet1 - cbet2 * sbet1,</span>
<span class="lineNum">    1290 </span><span class="lineCov">       1680 :     cbet12 = cbet2 * cbet1 + sbet2 * sbet1;</span>
<span class="lineNum">    1291 </span>            :   real sbet12a;
<span class="lineNum">    1292 </span><span class="lineCov">       3113 :   boolx shortline = cbet12 &gt;= 0 &amp;&amp; sbet12 &lt; (real)(0.5) &amp;&amp;</span>
<span class="lineNum">    1293 </span><span class="lineCov">       1433 :     cbet2 * lam12 &lt; (real)(0.5);</span>
<span class="lineNum">    1294 </span>            :   real somg12, comg12, ssig12, csig12;
<span class="lineNum">    1295 </span>            : #if defined(__GNUC__) &amp;&amp; __GNUC__ == 4 &amp;&amp;       \
<span class="lineNum">    1296 </span>            :   (__GNUC_MINOR__ &lt; 6 || defined(__MINGW32__))
<span class="lineNum">    1297 </span>            :   /* Volatile declaration needed to fix inverse cases
<span class="lineNum">    1298 </span>            :    * 88.202499451857 0 -88.202499451857 179.981022032992859592
<span class="lineNum">    1299 </span>            :    * 89.262080389218 0 -89.262080389218 179.992207982775375662
<span class="lineNum">    1300 </span>            :    * 89.333123580033 0 -89.333123580032997687 179.99295812360148422
<span class="lineNum">    1301 </span>            :    * which otherwise fail with g++ 4.4.4 x86 -O3 (Linux)
<span class="lineNum">    1302 </span>            :    * and g++ 4.4.0 (mingw) and g++ 4.6.1 (tdm mingw). */
<span class="lineNum">    1303 </span>            :   {
<span class="lineNum">    1304 </span>            :     volatile real xx1 = sbet2 * cbet1;
<span class="lineNum">    1305 </span>            :     volatile real xx2 = cbet2 * sbet1;
<span class="lineNum">    1306 </span>            :     sbet12a = xx1 + xx2;
<span class="lineNum">    1307 </span>            :   }
<span class="lineNum">    1308 </span>            : #else
<span class="lineNum">    1309 </span><span class="lineCov">       1680 :   sbet12a = sbet2 * cbet1 + cbet2 * sbet1;</span>
<span class="lineNum">    1310 </span>            : #endif
<span class="lineNum">    1311 </span><span class="lineCov">       1680 :   if (shortline) {</span>
<span class="lineNum">    1312 </span><span class="lineCov">       1200 :     real sbetm2 = sq(sbet1 + sbet2), omg12;</span>
<span class="lineNum">    1313 </span>            :     /* sin((bet1+bet2)/2)^2
<span class="lineNum">    1314 </span>            :      * =  (sbet1 + sbet2)^2 / ((sbet1 + sbet2)^2 + (cbet1 + cbet2)^2) */
<span class="lineNum">    1315 </span><span class="lineCov">       1200 :     sbetm2 /= sbetm2 + sq(cbet1 + cbet2);</span>
<span class="lineNum">    1316 </span><span class="lineCov">       1200 :     dnm = sqrt(1 + g-&gt;ep2 * sbetm2);</span>
<span class="lineNum">    1317 </span><span class="lineCov">       1200 :     omg12 = lam12 / (g-&gt;f1 * dnm);</span>
<span class="lineNum">    1318 </span><span class="lineCov">       1200 :     somg12 = sin(omg12); comg12 = cos(omg12);</span>
<span class="lineNum">    1319 </span>            :   } else {
<span class="lineNum">    1320 </span><span class="lineCov">        480 :     somg12 = slam12; comg12 = clam12;</span>
<span class="lineNum">    1321 </span>            :   }
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span><span class="lineCov">       1680 :   salp1 = cbet2 * somg12;</span>
<span class="lineNum">    1324 </span><span class="lineCov">       1680 :   calp1 = comg12 &gt;= 0 ?</span>
<span class="lineNum">    1325 </span><span class="lineCov">       1967 :     sbet12 + cbet2 * sbet1 * sq(somg12) / (1 + comg12) :</span>
<span class="lineNum">    1326 </span><span class="lineCov">        287 :     sbet12a - cbet2 * sbet1 * sq(somg12) / (1 - comg12);</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span><span class="lineCov">       1680 :   ssig12 = hypotx(salp1, calp1);</span>
<span class="lineNum">    1329 </span><span class="lineCov">       1680 :   csig12 = sbet1 * sbet2 + cbet1 * cbet2 * comg12;</span>
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span><span class="lineCov">       1680 :   if (shortline &amp;&amp; ssig12 &lt; g-&gt;etol2) {</span>
<span class="lineNum">    1332 </span>            :     /* really short lines */
<span class="lineNum">    1333 </span><span class="lineCov">       1096 :     salp2 = cbet1 * somg12;</span>
<span class="lineNum">    1334 </span><span class="lineCov">       2192 :     calp2 = sbet12 - cbet1 * sbet2 *</span>
<span class="lineNum">    1335 </span><span class="lineCov">       1096 :       (comg12 &gt;= 0 ? sq(somg12) / (1 + comg12) : 1 - comg12);</span>
<span class="lineNum">    1336 </span><span class="lineCov">       1096 :     norm2(&amp;salp2, &amp;calp2);</span>
<span class="lineNum">    1337 </span>            :     /* Set return value */
<span class="lineNum">    1338 </span><span class="lineCov">       1096 :     sig12 = atan2(ssig12, csig12);</span>
<span class="lineNum">    1339 </span><span class="lineCov">        584 :   } else if (fabs(g-&gt;n) &gt; (real)(0.1) || /* No astroid calc if too eccentric */</span>
<span class="lineNum">    1340 </span><span class="lineCov">         71 :              csig12 &gt;= 0 ||</span>
<span class="lineNum">    1341 </span><span class="lineCov">         71 :              ssig12 &gt;= 6 * fabs(g-&gt;n) * pi * sq(cbet1)) {</span>
<span class="lineNum">    1342 </span>            :     /* Nothing to do, zeroth order spherical approximation is OK */
<span class="lineNum">    1343 </span>            :   } else {
<span class="lineNum">    1344 </span>            :     /* Scale lam12 and bet2 to x, y coordinate system where antipodal point
<span class="lineNum">    1345 </span>            :      * is at origin and singular point is at y = 0, x = -1. */
<span class="lineNum">    1346 </span>            :     real y, lamscale, betscale;
<span class="lineNum">    1347 </span>            :     /* Volatile declaration needed to fix inverse case
<span class="lineNum">    1348 </span>            :      * 56.320923501171 0 -56.320923501171 179.664747671772880215
<span class="lineNum">    1349 </span>            :      * which otherwise fails with g++ 4.4.4 x86 -O3 */
<span class="lineNum">    1350 </span>            :     volatile real x;
<span class="lineNum">    1351 </span><span class="lineCov">         37 :     real lam12x = atan2(-slam12, -clam12); /* lam12 - pi */</span>
<span class="lineNum">    1352 </span><span class="lineCov">         37 :     if (g-&gt;f &gt;= 0) {            /* In fact f == 0 does not get here */</span>
<span class="lineNum">    1353 </span>            :       /* x = dlong, y = dlat */
<span class="lineNum">    1354 </span>            :       {
<span class="lineNum">    1355 </span>            :         real
<span class="lineNum">    1356 </span><span class="lineCov">         31 :           k2 = sq(sbet1) * g-&gt;ep2,</span>
<span class="lineNum">    1357 </span><span class="lineCov">         31 :           eps = k2 / (2 * (1 + sqrt(1 + k2)) + k2);</span>
<span class="lineNum">    1358 </span><span class="lineCov">         31 :         lamscale = g-&gt;f * cbet1 * A3f(g, eps) * pi;</span>
<span class="lineNum">    1359 </span>            :       }
<span class="lineNum">    1360 </span><span class="lineCov">         31 :       betscale = lamscale * cbet1;</span>
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span><span class="lineCov">         31 :       x = lam12x / lamscale;</span>
<span class="lineNum">    1363 </span><span class="lineCov">         31 :       y = sbet12a / betscale;</span>
<span class="lineNum">    1364 </span>            :     } else {                    /* f &lt; 0 */
<span class="lineNum">    1365 </span>            :       /* x = dlat, y = dlong */
<span class="lineNum">    1366 </span>            :       real
<span class="lineNum">    1367 </span><span class="lineCov">          6 :         cbet12a = cbet2 * cbet1 - sbet2 * sbet1,</span>
<span class="lineNum">    1368 </span><span class="lineCov">          6 :         bet12a = atan2(sbet12a, cbet12a);</span>
<span class="lineNum">    1369 </span>            :       real m12b, m0;
<span class="lineNum">    1370 </span>            :       /* In the case of lon12 = 180, this repeats a calculation made in
<span class="lineNum">    1371 </span>            :        * Inverse. */
<span class="lineNum">    1372 </span><span class="lineCov">          6 :       Lengths(g, g-&gt;n, pi + bet12a,</span>
<span class="lineNum">    1373 </span>            :               sbet1, -cbet1, dn1, sbet2, cbet2, dn2,
<span class="lineNum">    1374 </span>            :               cbet1, cbet2, 0, &amp;m12b, &amp;m0, 0, 0, Ca);
<span class="lineNum">    1375 </span><span class="lineCov">          6 :       x = -1 + m12b / (cbet1 * cbet2 * m0 * pi);</span>
<span class="lineNum">    1376 </span><span class="lineCov">         10 :       betscale = x &lt; -(real)(0.01) ? sbet12a / x :</span>
<span class="lineNum">    1377 </span><span class="lineCov">          4 :         -g-&gt;f * sq(cbet1) * pi;</span>
<span class="lineNum">    1378 </span><span class="lineCov">          6 :       lamscale = betscale / cbet1;</span>
<span class="lineNum">    1379 </span><span class="lineCov">          6 :       y = lam12x / lamscale;</span>
<span class="lineNum">    1380 </span>            :     }
<span class="lineNum">    1381 </span>            : 
<span class="lineNum">    1382 </span><span class="lineCov">         37 :     if (y &gt; -tol1 &amp;&amp; x &gt; -1 - xthresh) {</span>
<span class="lineNum">    1383 </span>            :       /* strip near cut */
<span class="lineNum">    1384 </span><span class="lineCov">         40 :       if (g-&gt;f &gt;= 0) {</span>
<span class="lineNum">    1385 </span><span class="lineCov">         14 :         salp1 = minx((real)(1), -(real)(x)); calp1 = - sqrt(1 - sq(salp1));</span>
<span class="lineNum">    1386 </span>            :       } else {
<span class="lineNum">    1387 </span><span class="lineCov">          6 :         calp1 = maxx((real)(x &gt; -tol1 ? 0 : -1), (real)(x));</span>
<span class="lineNum">    1388 </span><span class="lineCov">          6 :         salp1 = sqrt(1 - sq(calp1));</span>
<span class="lineNum">    1389 </span>            :       }
<span class="lineNum">    1390 </span>            :     } else {
<span class="lineNum">    1391 </span>            :       /* Estimate alp1, by solving the astroid problem.
<span class="lineNum">    1392 </span>            :        *
<span class="lineNum">    1393 </span>            :        * Could estimate alpha1 = theta + pi/2, directly, i.e.,
<span class="lineNum">    1394 </span>            :        *   calp1 = y/k; salp1 = -x/(1+k);  for f &gt;= 0
<span class="lineNum">    1395 </span>            :        *   calp1 = x/(1+k); salp1 = -y/k;  for f &lt; 0 (need to check)
<span class="lineNum">    1396 </span>            :        *
<span class="lineNum">    1397 </span>            :        * However, it's better to estimate omg12 from astroid and use
<span class="lineNum">    1398 </span>            :        * spherical formula to compute alp1.  This reduces the mean number of
<span class="lineNum">    1399 </span>            :        * Newton iterations for astroid cases from 2.24 (min 0, max 6) to 2.12
<span class="lineNum">    1400 </span>            :        * (min 0 max 5).  The changes in the number of iterations are as
<span class="lineNum">    1401 </span>            :        * follows:
<span class="lineNum">    1402 </span>            :        *
<span class="lineNum">    1403 </span>            :        * change percent
<span class="lineNum">    1404 </span>            :        *    1       5
<span class="lineNum">    1405 </span>            :        *    0      78
<span class="lineNum">    1406 </span>            :        *   -1      16
<span class="lineNum">    1407 </span>            :        *   -2       0.6
<span class="lineNum">    1408 </span>            :        *   -3       0.04
<span class="lineNum">    1409 </span>            :        *   -4       0.002
<span class="lineNum">    1410 </span>            :        *
<span class="lineNum">    1411 </span>            :        * The histogram of iterations is (m = number of iterations estimating
<span class="lineNum">    1412 </span>            :        * alp1 directly, n = number of iterations estimating via omg12, total
<span class="lineNum">    1413 </span>            :        * number of trials = 148605):
<span class="lineNum">    1414 </span>            :        *
<span class="lineNum">    1415 </span>            :        *  iter    m      n
<span class="lineNum">    1416 </span>            :        *    0   148    186
<span class="lineNum">    1417 </span>            :        *    1 13046  13845
<span class="lineNum">    1418 </span>            :        *    2 93315 102225
<span class="lineNum">    1419 </span>            :        *    3 36189  32341
<span class="lineNum">    1420 </span>            :        *    4  5396      7
<span class="lineNum">    1421 </span>            :        *    5   455      1
<span class="lineNum">    1422 </span>            :        *    6    56      0
<span class="lineNum">    1423 </span>            :        *
<span class="lineNum">    1424 </span>            :        * Because omg12 is near pi, estimate work with omg12a = pi - omg12 */
<span class="lineNum">    1425 </span><span class="lineCov">         17 :       real k = Astroid(x, y);</span>
<span class="lineNum">    1426 </span>            :       real
<span class="lineNum">    1427 </span><span class="lineCov">         17 :         omg12a = lamscale * ( g-&gt;f &gt;= 0 ? -x * k/(1 + k) : -y * (1 + k)/k );</span>
<span class="lineNum">    1428 </span><span class="lineCov">         17 :       somg12 = sin(omg12a); comg12 = -cos(omg12a);</span>
<span class="lineNum">    1429 </span>            :       /* Update spherical estimate of alp1 using omg12 instead of lam12 */
<span class="lineNum">    1430 </span><span class="lineCov">         17 :       salp1 = cbet2 * somg12;</span>
<span class="lineNum">    1431 </span><span class="lineCov">         17 :       calp1 = sbet12a - cbet2 * sbet1 * sq(somg12) / (1 - comg12);</span>
<span class="lineNum">    1432 </span>            :     }
<span class="lineNum">    1433 </span>            :   }
<span class="lineNum">    1434 </span>            :   /* Sanity check on starting guess.  Backwards check allows NaN through. */
<span class="lineNum">    1435 </span><span class="lineCov">       1680 :   if (!(salp1 &lt;= 0))</span>
<span class="lineNum">    1436 </span><span class="lineCov">       1678 :     norm2(&amp;salp1, &amp;calp1);</span>
<span class="lineNum">    1437 </span>            :   else {
<span class="lineNum">    1438 </span><span class="lineCov">          2 :     salp1 = 1; calp1 = 0;</span>
<span class="lineNum">    1439 </span>            :   }
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span><span class="lineCov">       1680 :   *psalp1 = salp1;</span>
<span class="lineNum">    1442 </span><span class="lineCov">       1680 :   *pcalp1 = calp1;</span>
<span class="lineNum">    1443 </span><span class="lineCov">       1680 :   if (shortline)</span>
<span class="lineNum">    1444 </span><span class="lineCov">       1200 :     *pdnm = dnm;</span>
<span class="lineNum">    1445 </span><span class="lineCov">       1680 :   if (sig12 &gt;= 0) {</span>
<span class="lineNum">    1446 </span><span class="lineCov">       1096 :     *psalp2 = salp2;</span>
<span class="lineNum">    1447 </span><span class="lineCov">       1096 :     *pcalp2 = calp2;</span>
<span class="lineNum">    1448 </span>            :   }
<span class="lineNum">    1449 </span><span class="lineCov">       1680 :   return sig12;</span>
<a name="1450"><span class="lineNum">    1450 </span>            : }</a>
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span><span class="lineCov">       1986 : real Lambda12(const struct geod_geodesic* g,</span>
<span class="lineNum">    1453 </span>            :               real sbet1, real cbet1, real dn1,
<span class="lineNum">    1454 </span>            :               real sbet2, real cbet2, real dn2,
<span class="lineNum">    1455 </span>            :               real salp1, real calp1,
<span class="lineNum">    1456 </span>            :               real slam120, real clam120,
<span class="lineNum">    1457 </span>            :               real* psalp2, real* pcalp2,
<span class="lineNum">    1458 </span>            :               real* psig12,
<span class="lineNum">    1459 </span>            :               real* pssig1, real* pcsig1,
<span class="lineNum">    1460 </span>            :               real* pssig2, real* pcsig2,
<span class="lineNum">    1461 </span>            :               real* peps,
<span class="lineNum">    1462 </span>            :               real* pdomg12,
<span class="lineNum">    1463 </span>            :               boolx diffp, real* pdlam12,
<span class="lineNum">    1464 </span>            :               /* Scratch area of the right size */
<span class="lineNum">    1465 </span>            :               real Ca[]) {
<span class="lineNum">    1466 </span><span class="lineCov">       1986 :   real salp2 = 0, calp2 = 0, sig12 = 0,</span>
<span class="lineNum">    1467 </span><span class="lineCov">       1986 :     ssig1 = 0, csig1 = 0, ssig2 = 0, csig2 = 0, eps = 0,</span>
<span class="lineNum">    1468 </span><span class="lineCov">       1986 :     domg12 = 0, dlam12 = 0;</span>
<span class="lineNum">    1469 </span>            :   real salp0, calp0;
<span class="lineNum">    1470 </span>            :   real somg1, comg1, somg2, comg2, somg12, comg12, lam12;
<span class="lineNum">    1471 </span>            :   real B312, eta, k2;
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineCov">       1986 :   if (sbet1 == 0 &amp;&amp; calp1 == 0)</span>
<span class="lineNum">    1474 </span>            :     /* Break degeneracy of equatorial line.  This case has already been
<span class="lineNum">    1475 </span>            :      * handled. */
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :     calp1 = -tiny;</span>
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span>            :   /* sin(alp1) * cos(bet1) = sin(alp0) */
<span class="lineNum">    1479 </span><span class="lineCov">       1986 :   salp0 = salp1 * cbet1;</span>
<span class="lineNum">    1480 </span><span class="lineCov">       1986 :   calp0 = hypotx(calp1, salp1 * sbet1); /* calp0 &gt; 0 */</span>
<span class="lineNum">    1481 </span>            : 
<span class="lineNum">    1482 </span>            :   /* tan(bet1) = tan(sig1) * cos(alp1)
<span class="lineNum">    1483 </span>            :    * tan(omg1) = sin(alp0) * tan(sig1) = tan(omg1)=tan(alp1)*sin(bet1) */
<span class="lineNum">    1484 </span><span class="lineCov">       1986 :   ssig1 = sbet1; somg1 = salp0 * sbet1;</span>
<span class="lineNum">    1485 </span><span class="lineCov">       1986 :   csig1 = comg1 = calp1 * cbet1;</span>
<span class="lineNum">    1486 </span><span class="lineCov">       1986 :   norm2(&amp;ssig1, &amp;csig1);</span>
<span class="lineNum">    1487 </span>            :   /* norm2(&amp;somg1, &amp;comg1); -- don't need to normalize! */
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span>            :   /* Enforce symmetries in the case abs(bet2) = -bet1.  Need to be careful
<span class="lineNum">    1490 </span>            :    * about this case, since this can yield singularities in the Newton
<span class="lineNum">    1491 </span>            :    * iteration.
<span class="lineNum">    1492 </span>            :    * sin(alp2) * cos(bet2) = sin(alp0) */
<span class="lineNum">    1493 </span><span class="lineCov">       1986 :   salp2 = cbet2 != cbet1 ? salp0 / cbet2 : salp1;</span>
<span class="lineNum">    1494 </span>            :   /* calp2 = sqrt(1 - sq(salp2))
<span class="lineNum">    1495 </span>            :    *       = sqrt(sq(calp0) - sq(sbet2)) / cbet2
<span class="lineNum">    1496 </span>            :    * and subst for calp0 and rearrange to give (choose positive sqrt
<span class="lineNum">    1497 </span>            :    * to give alp2 in [0, pi/2]). */
<span class="lineNum">    1498 </span><span class="lineCov">       2793 :   calp2 = cbet2 != cbet1 || fabs(sbet2) != -sbet1 ?</span>
<span class="lineNum">    1499 </span><span class="lineCov">       2366 :     sqrt(sq(calp1 * cbet1) +</span>
<span class="lineNum">    1500 </span><span class="lineCov">       1183 :          (cbet1 &lt; -sbet1 ?</span>
<span class="lineNum">    1501 </span><span class="lineCov">       2244 :           (cbet2 - cbet1) * (cbet1 + cbet2) :</span>
<span class="lineNum">    1502 </span><span class="lineCov">       4230 :           (sbet1 - sbet2) * (sbet1 + sbet2))) / cbet2 :</span>
<span class="lineNum">    1503 </span>            :     fabs(calp1);
<span class="lineNum">    1504 </span>            :   /* tan(bet2) = tan(sig2) * cos(alp2)
<span class="lineNum">    1505 </span>            :    * tan(omg2) = sin(alp0) * tan(sig2). */
<span class="lineNum">    1506 </span><span class="lineCov">       1986 :   ssig2 = sbet2; somg2 = salp0 * sbet2;</span>
<span class="lineNum">    1507 </span><span class="lineCov">       1986 :   csig2 = comg2 = calp2 * cbet2;</span>
<span class="lineNum">    1508 </span><span class="lineCov">       1986 :   norm2(&amp;ssig2, &amp;csig2);</span>
<span class="lineNum">    1509 </span>            :   /* norm2(&amp;somg2, &amp;comg2); -- don't need to normalize! */
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span>            :   /* sig12 = sig2 - sig1, limit to [0, pi] */
<span class="lineNum">    1512 </span><span class="lineCov">       1986 :   sig12 = atan2(maxx((real)(0), csig1 * ssig2 - ssig1 * csig2),</span>
<span class="lineNum">    1513 </span><span class="lineCov">       1986 :                                 csig1 * csig2 + ssig1 * ssig2);</span>
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            :   /* omg12 = omg2 - omg1, limit to [0, pi] */
<span class="lineNum">    1516 </span><span class="lineCov">       1986 :   somg12 = maxx((real)(0), comg1 * somg2 - somg1 * comg2);</span>
<span class="lineNum">    1517 </span><span class="lineCov">       1986 :   comg12 =                 comg1 * comg2 + somg1 * somg2;</span>
<span class="lineNum">    1518 </span>            :   /* eta = omg12 - lam120 */
<span class="lineNum">    1519 </span><span class="lineCov">       1986 :   eta = atan2(somg12 * clam120 - comg12 * slam120,</span>
<span class="lineNum">    1520 </span><span class="lineCov">       1986 :               comg12 * clam120 + somg12 * slam120);</span>
<span class="lineNum">    1521 </span><span class="lineCov">       1986 :   k2 = sq(calp0) * g-&gt;ep2;</span>
<span class="lineNum">    1522 </span><span class="lineCov">       1986 :   eps = k2 / (2 * (1 + sqrt(1 + k2)) + k2);</span>
<span class="lineNum">    1523 </span><span class="lineCov">       1986 :   C3f(g, eps, Ca);</span>
<span class="lineNum">    1524 </span><span class="lineCov">       3972 :   B312 = (SinCosSeries(TRUE, ssig2, csig2, Ca, nC3-1) -</span>
<span class="lineNum">    1525 </span><span class="lineCov">       1986 :           SinCosSeries(TRUE, ssig1, csig1, Ca, nC3-1));</span>
<span class="lineNum">    1526 </span><span class="lineCov">       1986 :   domg12 = -g-&gt;f * A3f(g, eps) * salp0 * (sig12 + B312);</span>
<span class="lineNum">    1527 </span><span class="lineCov">       1986 :   lam12 = eta + domg12;</span>
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span><span class="lineCov">       1986 :   if (diffp) {</span>
<span class="lineNum">    1530 </span><span class="lineCov">       1986 :     if (calp2 == 0)</span>
<span class="lineNum">    1531 </span><span class="lineCov">         12 :       dlam12 = - 2 * g-&gt;f1 * dn1 / sbet1;</span>
<span class="lineNum">    1532 </span>            :     else {
<span class="lineNum">    1533 </span><span class="lineCov">       1974 :       Lengths(g, eps, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2,</span>
<span class="lineNum">    1534 </span>            :               cbet1, cbet2, 0, &amp;dlam12, 0, 0, 0, Ca);
<span class="lineNum">    1535 </span><span class="lineCov">       1974 :       dlam12 *= g-&gt;f1 / (calp2 * cbet2);</span>
<span class="lineNum">    1536 </span>            :     }
<span class="lineNum">    1537 </span>            :   }
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span><span class="lineCov">       1986 :   *psalp2 = salp2;</span>
<span class="lineNum">    1540 </span><span class="lineCov">       1986 :   *pcalp2 = calp2;</span>
<span class="lineNum">    1541 </span><span class="lineCov">       1986 :   *psig12 = sig12;</span>
<span class="lineNum">    1542 </span><span class="lineCov">       1986 :   *pssig1 = ssig1;</span>
<span class="lineNum">    1543 </span><span class="lineCov">       1986 :   *pcsig1 = csig1;</span>
<span class="lineNum">    1544 </span><span class="lineCov">       1986 :   *pssig2 = ssig2;</span>
<span class="lineNum">    1545 </span><span class="lineCov">       1986 :   *pcsig2 = csig2;</span>
<span class="lineNum">    1546 </span><span class="lineCov">       1986 :   *peps = eps;</span>
<span class="lineNum">    1547 </span><span class="lineCov">       1986 :   *pdomg12 = domg12;</span>
<span class="lineNum">    1548 </span><span class="lineCov">       1986 :   if (diffp)</span>
<span class="lineNum">    1549 </span><span class="lineCov">       1986 :     *pdlam12 = dlam12;</span>
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span><span class="lineCov">       1986 :   return lam12;</span>
<a name="1552"><span class="lineNum">    1552 </span>            : }</a>
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span><span class="lineCov">       3049 : real A3f(const struct geod_geodesic* g, real eps) {</span>
<span class="lineNum">    1555 </span>            :   /* Evaluate A3 */
<span class="lineNum">    1556 </span><span class="lineCov">       3049 :   return polyval(nA3 - 1, g-&gt;A3x, eps);</span>
<a name="1557"><span class="lineNum">    1557 </span>            : }</a>
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span><span class="lineCov">       3018 : void C3f(const struct geod_geodesic* g, real eps, real c[]) {</span>
<span class="lineNum">    1560 </span>            :   /* Evaluate C3 coeffs
<span class="lineNum">    1561 </span>            :    * Elements c[1] through c[nC3 - 1] are set */
<span class="lineNum">    1562 </span><span class="lineCov">       3018 :   real mult = 1;</span>
<span class="lineNum">    1563 </span><span class="lineCov">       3018 :   int o = 0, l;</span>
<span class="lineNum">    1564 </span><span class="lineCov">      18108 :   for (l = 1; l &lt; nC3; ++l) {   /* l is index of C3[l] */</span>
<span class="lineNum">    1565 </span><span class="lineCov">      15090 :     int m = nC3 - l - 1;        /* order of polynomial in eps */</span>
<span class="lineNum">    1566 </span><span class="lineCov">      15090 :     mult *= eps;</span>
<span class="lineNum">    1567 </span><span class="lineCov">      15090 :     c[l] = mult * polyval(m, g-&gt;C3x + o, eps);</span>
<span class="lineNum">    1568 </span><span class="lineCov">      15090 :     o += m + 1;</span>
<span class="lineNum">    1569 </span>            :   }
<a name="1570"><span class="lineNum">    1570 </span><span class="lineCov">       3018 : }</span></a>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineCov">        348 : void C4f(const struct geod_geodesic* g, real eps, real c[]) {</span>
<span class="lineNum">    1573 </span>            :   /* Evaluate C4 coeffs
<span class="lineNum">    1574 </span>            :    * Elements c[0] through c[nC4 - 1] are set */
<span class="lineNum">    1575 </span><span class="lineCov">        348 :   real mult = 1;</span>
<span class="lineNum">    1576 </span><span class="lineCov">        348 :   int o = 0, l;</span>
<span class="lineNum">    1577 </span><span class="lineCov">       2436 :   for (l = 0; l &lt; nC4; ++l) {   /* l is index of C4[l] */</span>
<span class="lineNum">    1578 </span><span class="lineCov">       2088 :     int m = nC4 - l - 1;        /* order of polynomial in eps */</span>
<span class="lineNum">    1579 </span><span class="lineCov">       2088 :     c[l] = mult * polyval(m, g-&gt;C4x + o, eps);</span>
<span class="lineNum">    1580 </span><span class="lineCov">       2088 :     o += m + 1;</span>
<span class="lineNum">    1581 </span><span class="lineCov">       2088 :     mult *= eps;</span>
<span class="lineNum">    1582 </span>            :   }
<span class="lineNum">    1583 </span><span class="lineCov">        348 : }</span>
<a name="1584"><span class="lineNum">    1584 </span>            : </a>
<span class="lineNum">    1585 </span>            : /* The scale factor A1-1 = mean value of (d/dsigma)I1 - 1 */
<span class="lineNum">    1586 </span><span class="lineCov">       4375 : real A1m1f(real eps)  {</span>
<span class="lineNum">    1587 </span>            :   static const real coeff[] = {
<span class="lineNum">    1588 </span>            :     /* (1-eps)*A1-1, polynomial in eps2 of order 3 */
<span class="lineNum">    1589 </span>            :     1, 4, 64, 0, 256,
<span class="lineNum">    1590 </span>            :   };
<span class="lineNum">    1591 </span><span class="lineCov">       4375 :   int m = nA1/2;</span>
<span class="lineNum">    1592 </span><span class="lineCov">       4375 :   real t = polyval(m, coeff, sq(eps)) / coeff[m + 1];</span>
<span class="lineNum">    1593 </span><span class="lineCov">       4375 :   return (t + eps) / (1 - eps);</span>
<span class="lineNum">    1594 </span>            : }
<a name="1595"><span class="lineNum">    1595 </span>            : </a>
<span class="lineNum">    1596 </span>            : /* The coefficients C1[l] in the Fourier expansion of B1 */
<span class="lineNum">    1597 </span><span class="lineCov">       4375 : void C1f(real eps, real c[])  {</span>
<span class="lineNum">    1598 </span>            :   static const real coeff[] = {
<span class="lineNum">    1599 </span>            :     /* C1[1]/eps^1, polynomial in eps2 of order 2 */
<span class="lineNum">    1600 </span>            :     -1, 6, -16, 32,
<span class="lineNum">    1601 </span>            :     /* C1[2]/eps^2, polynomial in eps2 of order 2 */
<span class="lineNum">    1602 </span>            :     -9, 64, -128, 2048,
<span class="lineNum">    1603 </span>            :     /* C1[3]/eps^3, polynomial in eps2 of order 1 */
<span class="lineNum">    1604 </span>            :     9, -16, 768,
<span class="lineNum">    1605 </span>            :     /* C1[4]/eps^4, polynomial in eps2 of order 1 */
<span class="lineNum">    1606 </span>            :     3, -5, 512,
<span class="lineNum">    1607 </span>            :     /* C1[5]/eps^5, polynomial in eps2 of order 0 */
<span class="lineNum">    1608 </span>            :     -7, 1280,
<span class="lineNum">    1609 </span>            :     /* C1[6]/eps^6, polynomial in eps2 of order 0 */
<span class="lineNum">    1610 </span>            :     -7, 2048,
<span class="lineNum">    1611 </span>            :   };
<span class="lineNum">    1612 </span>            :   real
<span class="lineNum">    1613 </span><span class="lineCov">       4375 :     eps2 = sq(eps),</span>
<span class="lineNum">    1614 </span><span class="lineCov">       4375 :     d = eps;</span>
<span class="lineNum">    1615 </span><span class="lineCov">       4375 :   int o = 0, l;</span>
<span class="lineNum">    1616 </span><span class="lineCov">      30625 :   for (l = 1; l &lt;= nC1; ++l) {  /* l is index of C1p[l] */</span>
<span class="lineNum">    1617 </span><span class="lineCov">      26250 :     int m = (nC1 - l) / 2;      /* order of polynomial in eps^2 */</span>
<span class="lineNum">    1618 </span><span class="lineCov">      26250 :     c[l] = d * polyval(m, coeff + o, eps2) / coeff[o + m + 1];</span>
<span class="lineNum">    1619 </span><span class="lineCov">      26250 :     o += m + 2;</span>
<span class="lineNum">    1620 </span><span class="lineCov">      26250 :     d *= eps;</span>
<span class="lineNum">    1621 </span>            :   }
<span class="lineNum">    1622 </span><span class="lineCov">       4375 : }</span>
<a name="1623"><span class="lineNum">    1623 </span>            : </a>
<span class="lineNum">    1624 </span>            : /* The coefficients C1p[l] in the Fourier expansion of B1p */
<span class="lineNum">    1625 </span><span class="lineCov">        996 : void C1pf(real eps, real c[])  {</span>
<span class="lineNum">    1626 </span>            :   static const real coeff[] = {
<span class="lineNum">    1627 </span>            :     /* C1p[1]/eps^1, polynomial in eps2 of order 2 */
<span class="lineNum">    1628 </span>            :     205, -432, 768, 1536,
<span class="lineNum">    1629 </span>            :     /* C1p[2]/eps^2, polynomial in eps2 of order 2 */
<span class="lineNum">    1630 </span>            :     4005, -4736, 3840, 12288,
<span class="lineNum">    1631 </span>            :     /* C1p[3]/eps^3, polynomial in eps2 of order 1 */
<span class="lineNum">    1632 </span>            :     -225, 116, 384,
<span class="lineNum">    1633 </span>            :     /* C1p[4]/eps^4, polynomial in eps2 of order 1 */
<span class="lineNum">    1634 </span>            :     -7173, 2695, 7680,
<span class="lineNum">    1635 </span>            :     /* C1p[5]/eps^5, polynomial in eps2 of order 0 */
<span class="lineNum">    1636 </span>            :     3467, 7680,
<span class="lineNum">    1637 </span>            :     /* C1p[6]/eps^6, polynomial in eps2 of order 0 */
<span class="lineNum">    1638 </span>            :     38081, 61440,
<span class="lineNum">    1639 </span>            :   };
<span class="lineNum">    1640 </span>            :   real
<span class="lineNum">    1641 </span><span class="lineCov">        996 :     eps2 = sq(eps),</span>
<span class="lineNum">    1642 </span><span class="lineCov">        996 :     d = eps;</span>
<span class="lineNum">    1643 </span><span class="lineCov">        996 :   int o = 0, l;</span>
<span class="lineNum">    1644 </span><span class="lineCov">       6972 :   for (l = 1; l &lt;= nC1p; ++l) { /* l is index of C1p[l] */</span>
<span class="lineNum">    1645 </span><span class="lineCov">       5976 :     int m = (nC1p - l) / 2;     /* order of polynomial in eps^2 */</span>
<span class="lineNum">    1646 </span><span class="lineCov">       5976 :     c[l] = d * polyval(m, coeff + o, eps2) / coeff[o + m + 1];</span>
<span class="lineNum">    1647 </span><span class="lineCov">       5976 :     o += m + 2;</span>
<span class="lineNum">    1648 </span><span class="lineCov">       5976 :     d *= eps;</span>
<span class="lineNum">    1649 </span>            :   }
<span class="lineNum">    1650 </span><span class="lineCov">        996 : }</span>
<a name="1651"><span class="lineNum">    1651 </span>            : </a>
<span class="lineNum">    1652 </span>            : /* The scale factor A2-1 = mean value of (d/dsigma)I2 - 1 */
<span class="lineNum">    1653 </span><span class="lineCov">       3421 : real A2m1f(real eps)  {</span>
<span class="lineNum">    1654 </span>            :   static const real coeff[] = {
<span class="lineNum">    1655 </span>            :     /* (eps+1)*A2-1, polynomial in eps2 of order 3 */
<span class="lineNum">    1656 </span>            :     -11, -28, -192, 0, 256,
<span class="lineNum">    1657 </span>            :   };
<span class="lineNum">    1658 </span><span class="lineCov">       3421 :   int m = nA2/2;</span>
<span class="lineNum">    1659 </span><span class="lineCov">       3421 :   real t = polyval(m, coeff, sq(eps)) / coeff[m + 1];</span>
<span class="lineNum">    1660 </span><span class="lineCov">       3421 :   return (t - eps) / (1 + eps);</span>
<span class="lineNum">    1661 </span>            : }
<a name="1662"><span class="lineNum">    1662 </span>            : </a>
<span class="lineNum">    1663 </span>            : /* The coefficients C2[l] in the Fourier expansion of B2 */
<span class="lineNum">    1664 </span><span class="lineCov">       3421 : void C2f(real eps, real c[])  {</span>
<span class="lineNum">    1665 </span>            :   static const real coeff[] = {
<span class="lineNum">    1666 </span>            :     /* C2[1]/eps^1, polynomial in eps2 of order 2 */
<span class="lineNum">    1667 </span>            :     1, 2, 16, 32,
<span class="lineNum">    1668 </span>            :     /* C2[2]/eps^2, polynomial in eps2 of order 2 */
<span class="lineNum">    1669 </span>            :     35, 64, 384, 2048,
<span class="lineNum">    1670 </span>            :     /* C2[3]/eps^3, polynomial in eps2 of order 1 */
<span class="lineNum">    1671 </span>            :     15, 80, 768,
<span class="lineNum">    1672 </span>            :     /* C2[4]/eps^4, polynomial in eps2 of order 1 */
<span class="lineNum">    1673 </span>            :     7, 35, 512,
<span class="lineNum">    1674 </span>            :     /* C2[5]/eps^5, polynomial in eps2 of order 0 */
<span class="lineNum">    1675 </span>            :     63, 1280,
<span class="lineNum">    1676 </span>            :     /* C2[6]/eps^6, polynomial in eps2 of order 0 */
<span class="lineNum">    1677 </span>            :     77, 2048,
<span class="lineNum">    1678 </span>            :   };
<span class="lineNum">    1679 </span>            :   real
<span class="lineNum">    1680 </span><span class="lineCov">       3421 :     eps2 = sq(eps),</span>
<span class="lineNum">    1681 </span><span class="lineCov">       3421 :     d = eps;</span>
<span class="lineNum">    1682 </span><span class="lineCov">       3421 :   int o = 0, l;</span>
<span class="lineNum">    1683 </span><span class="lineCov">      23947 :   for (l = 1; l &lt;= nC2; ++l) { /* l is index of C2[l] */</span>
<span class="lineNum">    1684 </span><span class="lineCov">      20526 :     int m = (nC2 - l) / 2;     /* order of polynomial in eps^2 */</span>
<span class="lineNum">    1685 </span><span class="lineCov">      20526 :     c[l] = d * polyval(m, coeff + o, eps2) / coeff[o + m + 1];</span>
<span class="lineNum">    1686 </span><span class="lineCov">      20526 :     o += m + 2;</span>
<span class="lineNum">    1687 </span><span class="lineCov">      20526 :     d *= eps;</span>
<span class="lineNum">    1688 </span>            :   }
<span class="lineNum">    1689 </span><span class="lineCov">       3421 : }</span>
<a name="1690"><span class="lineNum">    1690 </span>            : </a>
<span class="lineNum">    1691 </span>            : /* The scale factor A3 = mean value of (d/dsigma)I3 */
<span class="lineNum">    1692 </span><span class="lineCov">       2462 : void A3coeff(struct geod_geodesic* g) {</span>
<span class="lineNum">    1693 </span>            :   static const real coeff[] = {
<span class="lineNum">    1694 </span>            :     /* A3, coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1695 </span>            :     -3, 128,
<span class="lineNum">    1696 </span>            :     /* A3, coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1697 </span>            :     -2, -3, 64,
<span class="lineNum">    1698 </span>            :     /* A3, coeff of eps^3, polynomial in n of order 2 */
<span class="lineNum">    1699 </span>            :     -1, -3, -1, 16,
<span class="lineNum">    1700 </span>            :     /* A3, coeff of eps^2, polynomial in n of order 2 */
<span class="lineNum">    1701 </span>            :     3, -1, -2, 8,
<span class="lineNum">    1702 </span>            :     /* A3, coeff of eps^1, polynomial in n of order 1 */
<span class="lineNum">    1703 </span>            :     1, -1, 2,
<span class="lineNum">    1704 </span>            :     /* A3, coeff of eps^0, polynomial in n of order 0 */
<span class="lineNum">    1705 </span>            :     1, 1,
<span class="lineNum">    1706 </span>            :   };
<span class="lineNum">    1707 </span><span class="lineCov">       2462 :   int o = 0, k = 0, j;</span>
<span class="lineNum">    1708 </span><span class="lineCov">      17234 :   for (j = nA3 - 1; j &gt;= 0; --j) {             /* coeff of eps^j */</span>
<span class="lineNum">    1709 </span><span class="lineCov">      14772 :     int m = nA3 - j - 1 &lt; j ? nA3 - j - 1 : j; /* order of polynomial in n */</span>
<span class="lineNum">    1710 </span><span class="lineCov">      14772 :     g-&gt;A3x[k++] = polyval(m, coeff + o, g-&gt;n) / coeff[o + m + 1];</span>
<span class="lineNum">    1711 </span><span class="lineCov">      14772 :     o += m + 2;</span>
<span class="lineNum">    1712 </span>            :   }
<span class="lineNum">    1713 </span><span class="lineCov">       2462 : }</span>
<a name="1714"><span class="lineNum">    1714 </span>            : </a>
<span class="lineNum">    1715 </span>            : /* The coefficients C3[l] in the Fourier expansion of B3 */
<span class="lineNum">    1716 </span><span class="lineCov">       2462 : void C3coeff(struct geod_geodesic* g) {</span>
<span class="lineNum">    1717 </span>            :   static const real coeff[] = {
<span class="lineNum">    1718 </span>            :     /* C3[1], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1719 </span>            :     3, 128,
<span class="lineNum">    1720 </span>            :     /* C3[1], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1721 </span>            :     2, 5, 128,
<span class="lineNum">    1722 </span>            :     /* C3[1], coeff of eps^3, polynomial in n of order 2 */
<span class="lineNum">    1723 </span>            :     -1, 3, 3, 64,
<span class="lineNum">    1724 </span>            :     /* C3[1], coeff of eps^2, polynomial in n of order 2 */
<span class="lineNum">    1725 </span>            :     -1, 0, 1, 8,
<span class="lineNum">    1726 </span>            :     /* C3[1], coeff of eps^1, polynomial in n of order 1 */
<span class="lineNum">    1727 </span>            :     -1, 1, 4,
<span class="lineNum">    1728 </span>            :     /* C3[2], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1729 </span>            :     5, 256,
<span class="lineNum">    1730 </span>            :     /* C3[2], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1731 </span>            :     1, 3, 128,
<span class="lineNum">    1732 </span>            :     /* C3[2], coeff of eps^3, polynomial in n of order 2 */
<span class="lineNum">    1733 </span>            :     -3, -2, 3, 64,
<span class="lineNum">    1734 </span>            :     /* C3[2], coeff of eps^2, polynomial in n of order 2 */
<span class="lineNum">    1735 </span>            :     1, -3, 2, 32,
<span class="lineNum">    1736 </span>            :     /* C3[3], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1737 </span>            :     7, 512,
<span class="lineNum">    1738 </span>            :     /* C3[3], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1739 </span>            :     -10, 9, 384,
<span class="lineNum">    1740 </span>            :     /* C3[3], coeff of eps^3, polynomial in n of order 2 */
<span class="lineNum">    1741 </span>            :     5, -9, 5, 192,
<span class="lineNum">    1742 </span>            :     /* C3[4], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1743 </span>            :     7, 512,
<span class="lineNum">    1744 </span>            :     /* C3[4], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1745 </span>            :     -14, 7, 512,
<span class="lineNum">    1746 </span>            :     /* C3[5], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1747 </span>            :     21, 2560,
<span class="lineNum">    1748 </span>            :   };
<span class="lineNum">    1749 </span><span class="lineCov">       2462 :   int o = 0, k = 0, l, j;</span>
<span class="lineNum">    1750 </span><span class="lineCov">      14772 :   for (l = 1; l &lt; nC3; ++l) {                    /* l is index of C3[l] */</span>
<span class="lineNum">    1751 </span><span class="lineCov">      49240 :     for (j = nC3 - 1; j &gt;= l; --j) {             /* coeff of eps^j */</span>
<span class="lineNum">    1752 </span><span class="lineCov">      36930 :       int m = nC3 - j - 1 &lt; j ? nC3 - j - 1 : j; /* order of polynomial in n */</span>
<span class="lineNum">    1753 </span><span class="lineCov">      36930 :       g-&gt;C3x[k++] = polyval(m, coeff + o, g-&gt;n) / coeff[o + m + 1];</span>
<span class="lineNum">    1754 </span><span class="lineCov">      36930 :       o += m + 2;</span>
<span class="lineNum">    1755 </span>            :     }
<span class="lineNum">    1756 </span>            :   }
<span class="lineNum">    1757 </span><span class="lineCov">       2462 : }</span>
<a name="1758"><span class="lineNum">    1758 </span>            : </a>
<span class="lineNum">    1759 </span>            : /* The coefficients C4[l] in the Fourier expansion of I4 */
<span class="lineNum">    1760 </span><span class="lineCov">       2462 : void C4coeff(struct geod_geodesic* g) {</span>
<span class="lineNum">    1761 </span>            :   static const real coeff[] = {
<span class="lineNum">    1762 </span>            :     /* C4[0], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1763 </span>            :     97, 15015,
<span class="lineNum">    1764 </span>            :     /* C4[0], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1765 </span>            :     1088, 156, 45045,
<span class="lineNum">    1766 </span>            :     /* C4[0], coeff of eps^3, polynomial in n of order 2 */
<span class="lineNum">    1767 </span>            :     -224, -4784, 1573, 45045,
<span class="lineNum">    1768 </span>            :     /* C4[0], coeff of eps^2, polynomial in n of order 3 */
<span class="lineNum">    1769 </span>            :     -10656, 14144, -4576, -858, 45045,
<span class="lineNum">    1770 </span>            :     /* C4[0], coeff of eps^1, polynomial in n of order 4 */
<span class="lineNum">    1771 </span>            :     64, 624, -4576, 6864, -3003, 15015,
<span class="lineNum">    1772 </span>            :     /* C4[0], coeff of eps^0, polynomial in n of order 5 */
<span class="lineNum">    1773 </span>            :     100, 208, 572, 3432, -12012, 30030, 45045,
<span class="lineNum">    1774 </span>            :     /* C4[1], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1775 </span>            :     1, 9009,
<span class="lineNum">    1776 </span>            :     /* C4[1], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1777 </span>            :     -2944, 468, 135135,
<span class="lineNum">    1778 </span>            :     /* C4[1], coeff of eps^3, polynomial in n of order 2 */
<span class="lineNum">    1779 </span>            :     5792, 1040, -1287, 135135,
<span class="lineNum">    1780 </span>            :     /* C4[1], coeff of eps^2, polynomial in n of order 3 */
<span class="lineNum">    1781 </span>            :     5952, -11648, 9152, -2574, 135135,
<span class="lineNum">    1782 </span>            :     /* C4[1], coeff of eps^1, polynomial in n of order 4 */
<span class="lineNum">    1783 </span>            :     -64, -624, 4576, -6864, 3003, 135135,
<span class="lineNum">    1784 </span>            :     /* C4[2], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1785 </span>            :     8, 10725,
<span class="lineNum">    1786 </span>            :     /* C4[2], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1787 </span>            :     1856, -936, 225225,
<span class="lineNum">    1788 </span>            :     /* C4[2], coeff of eps^3, polynomial in n of order 2 */
<span class="lineNum">    1789 </span>            :     -8448, 4992, -1144, 225225,
<span class="lineNum">    1790 </span>            :     /* C4[2], coeff of eps^2, polynomial in n of order 3 */
<span class="lineNum">    1791 </span>            :     -1440, 4160, -4576, 1716, 225225,
<span class="lineNum">    1792 </span>            :     /* C4[3], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1793 </span>            :     -136, 63063,
<span class="lineNum">    1794 </span>            :     /* C4[3], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1795 </span>            :     1024, -208, 105105,
<span class="lineNum">    1796 </span>            :     /* C4[3], coeff of eps^3, polynomial in n of order 2 */
<span class="lineNum">    1797 </span>            :     3584, -3328, 1144, 315315,
<span class="lineNum">    1798 </span>            :     /* C4[4], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1799 </span>            :     -128, 135135,
<span class="lineNum">    1800 </span>            :     /* C4[4], coeff of eps^4, polynomial in n of order 1 */
<span class="lineNum">    1801 </span>            :     -2560, 832, 405405,
<span class="lineNum">    1802 </span>            :     /* C4[5], coeff of eps^5, polynomial in n of order 0 */
<span class="lineNum">    1803 </span>            :     128, 99099,
<span class="lineNum">    1804 </span>            :   };
<span class="lineNum">    1805 </span><span class="lineCov">       2462 :   int o = 0, k = 0, l, j;</span>
<span class="lineNum">    1806 </span><span class="lineCov">      17234 :   for (l = 0; l &lt; nC4; ++l) {        /* l is index of C4[l] */</span>
<span class="lineNum">    1807 </span><span class="lineCov">      66474 :     for (j = nC4 - 1; j &gt;= l; --j) { /* coeff of eps^j */</span>
<span class="lineNum">    1808 </span><span class="lineCov">      51702 :       int m = nC4 - j - 1;           /* order of polynomial in n */</span>
<span class="lineNum">    1809 </span><span class="lineCov">      51702 :       g-&gt;C4x[k++] = polyval(m, coeff + o, g-&gt;n) / coeff[o + m + 1];</span>
<span class="lineNum">    1810 </span><span class="lineCov">      51702 :       o += m + 2;</span>
<span class="lineNum">    1811 </span>            :     }
<span class="lineNum">    1812 </span>            :   }
<a name="1813"><span class="lineNum">    1813 </span><span class="lineCov">       2462 : }</span></a>
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span><span class="lineCov">        206 : int transit(real lon1, real lon2) {</span>
<span class="lineNum">    1816 </span>            :   real lon12;
<span class="lineNum">    1817 </span>            :   /* Return 1 or -1 if crossing prime meridian in east or west direction.
<span class="lineNum">    1818 </span>            :    * Otherwise return zero. */
<span class="lineNum">    1819 </span>            :   /* Compute lon12 the same way as Geodesic::Inverse. */
<span class="lineNum">    1820 </span><span class="lineCov">        206 :   lon1 = AngNormalize(lon1);</span>
<span class="lineNum">    1821 </span><span class="lineCov">        206 :   lon2 = AngNormalize(lon2);</span>
<span class="lineNum">    1822 </span><span class="lineCov">        206 :   lon12 = AngDiff(lon1, lon2, 0);</span>
<span class="lineNum">    1823 </span><span class="lineCov">        338 :   return lon1 &lt;= 0 &amp;&amp; lon2 &gt; 0 &amp;&amp; lon12 &gt; 0 ? 1 :</span>
<span class="lineNum">    1824 </span><span class="lineCov">        132 :     (lon2 &lt;= 0 &amp;&amp; lon1 &gt; 0 &amp;&amp; lon12 &lt; 0 ? -1 : 0);</span>
<a name="1825"><span class="lineNum">    1825 </span>            : }</a>
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span><span class="lineCov">         30 : int transitdirect(real lon1, real lon2) {</span>
<span class="lineNum">    1828 </span>            : #if HAVE_C99_MATH
<span class="lineNum">    1829 </span><span class="lineCov">         30 :   lon1 = remainder(lon1, (real)(720));</span>
<span class="lineNum">    1830 </span><span class="lineCov">         30 :   lon2 = remainder(lon2, (real)(720));</span>
<span class="lineNum">    1831 </span><span class="lineCov">         60 :   return ( (lon2 &lt;= 0 &amp;&amp; lon2 &gt; -360 ? 1 : 0) -</span>
<span class="lineNum">    1832 </span><span class="lineCov">         30 :            (lon1 &lt;= 0 &amp;&amp; lon1 &gt; -360 ? 1 : 0) );</span>
<span class="lineNum">    1833 </span>            : #else
<span class="lineNum">    1834 </span>            :   lon1 = fmod(lon1, (real)(720));
<span class="lineNum">    1835 </span>            :   lon2 = fmod(lon2, (real)(720));
<span class="lineNum">    1836 </span>            :   return ( ((lon2 &lt;= 0 &amp;&amp; lon2 &gt; -360) || lon2 &gt; 360 ? 1 : 0) -
<span class="lineNum">    1837 </span>            :            ((lon1 &lt;= 0 &amp;&amp; lon1 &gt; -360) || lon1 &gt; 360 ? 1 : 0) );
<span class="lineNum">    1838 </span>            : #endif
<a name="1839"><span class="lineNum">    1839 </span>            : }</a>
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span><span class="lineCov">         80 : void accini(real s[]) {</span>
<span class="lineNum">    1842 </span>            :   /* Initialize an accumulator; this is an array with two elements. */
<span class="lineNum">    1843 </span><span class="lineCov">         80 :   s[0] = s[1] = 0;</span>
<a name="1844"><span class="lineNum">    1844 </span><span class="lineCov">         80 : }</span></a>
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span><span class="lineCov">         72 : void acccopy(const real s[], real t[]) {</span>
<span class="lineNum">    1847 </span>            :   /* Copy an accumulator; t = s. */
<span class="lineNum">    1848 </span><span class="lineCov">         72 :   t[0] = s[0]; t[1] = s[1];</span>
<a name="1849"><span class="lineNum">    1849 </span><span class="lineCov">         72 : }</span></a>
<span class="lineNum">    1850 </span>            : 
<span class="lineNum">    1851 </span><span class="lineCov">        292 : void accadd(real s[], real y) {</span>
<span class="lineNum">    1852 </span>            :   /* Add y to an accumulator. */
<span class="lineNum">    1853 </span><span class="lineCov">        292 :   real u, z = sumx(y, s[1], &amp;u);</span>
<span class="lineNum">    1854 </span><span class="lineCov">        292 :   s[0] = sumx(z, s[0], &amp;s[1]);</span>
<span class="lineNum">    1855 </span><span class="lineCov">        292 :   if (s[0] == 0)</span>
<span class="lineNum">    1856 </span><span class="lineCov">         10 :     s[0] = u;</span>
<span class="lineNum">    1857 </span>            :   else
<span class="lineNum">    1858 </span><span class="lineCov">        282 :     s[1] = s[1] + u;</span>
<a name="1859"><span class="lineNum">    1859 </span><span class="lineCov">        292 : }</span></a>
<span class="lineNum">    1860 </span>            : 
<span class="lineNum">    1861 </span><span class="lineCov">         22 : real accsum(const real s[], real y) {</span>
<span class="lineNum">    1862 </span>            :   /* Return accumulator + y (but don't add to accumulator). */
<span class="lineNum">    1863 </span>            :   real t[2];
<span class="lineNum">    1864 </span><span class="lineCov">         22 :   acccopy(s, t);</span>
<span class="lineNum">    1865 </span><span class="lineCov">         22 :   accadd(t, y);</span>
<span class="lineNum">    1866 </span><span class="lineCov">         22 :   return t[0];</span>
<a name="1867"><span class="lineNum">    1867 </span>            : }</a>
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span><span class="lineCov">         38 : void accneg(real s[]) {</span>
<span class="lineNum">    1870 </span>            :   /* Negate an accumulator. */
<span class="lineNum">    1871 </span><span class="lineCov">         38 :   s[0] = -s[0]; s[1] = -s[1];</span>
<a name="1872"><span class="lineNum">    1872 </span><span class="lineCov">         38 : }</span></a>
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span><span class="lineCov">         40 : void geod_polygon_init(struct geod_polygon* p, boolx polylinep) {</span>
<span class="lineNum">    1875 </span><span class="lineCov">         40 :   p-&gt;polyline = (polylinep != 0);</span>
<span class="lineNum">    1876 </span><span class="lineCov">         40 :   geod_polygon_clear(p);</span>
<a name="1877"><span class="lineNum">    1877 </span><span class="lineCov">         40 : }</span></a>
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span><span class="lineCov">         40 : void geod_polygon_clear(struct geod_polygon* p) {</span>
<span class="lineNum">    1880 </span><span class="lineCov">         40 :   p-&gt;lat0 = p-&gt;lon0 = p-&gt;lat = p-&gt;lon = NaN;</span>
<span class="lineNum">    1881 </span><span class="lineCov">         40 :   accini(p-&gt;P);</span>
<span class="lineNum">    1882 </span><span class="lineCov">         40 :   accini(p-&gt;A);</span>
<span class="lineNum">    1883 </span><span class="lineCov">         40 :   p-&gt;num = p-&gt;crossings = 0;</span>
<a name="1884"><span class="lineNum">    1884 </span><span class="lineCov">         40 : }</span></a>
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineCov">        126 : void geod_polygon_addpoint(const struct geod_geodesic* g,</span>
<span class="lineNum">    1887 </span>            :                            struct geod_polygon* p,
<span class="lineNum">    1888 </span>            :                            real lat, real lon) {
<span class="lineNum">    1889 </span><span class="lineCov">        126 :   lon = AngNormalize(lon);</span>
<span class="lineNum">    1890 </span><span class="lineCov">        126 :   if (p-&gt;num == 0) {</span>
<span class="lineNum">    1891 </span><span class="lineCov">         38 :     p-&gt;lat0 = p-&gt;lat = lat;</span>
<span class="lineNum">    1892 </span><span class="lineCov">         38 :     p-&gt;lon0 = p-&gt;lon = lon;</span>
<span class="lineNum">    1893 </span>            :   } else {
<span class="lineNum">    1894 </span><span class="lineCov">         88 :     real s12, S12 = 0;       /* Initialize S12 to stop Visual Studio warning */</span>
<span class="lineNum">    1895 </span><span class="lineCov">         88 :     geod_geninverse(g, p-&gt;lat, p-&gt;lon, lat, lon,</span>
<span class="lineNum">    1896 </span><span class="lineCov">         88 :                     &amp;s12, 0, 0, 0, 0, 0, p-&gt;polyline ? 0 : &amp;S12);</span>
<span class="lineNum">    1897 </span><span class="lineCov">         88 :     accadd(p-&gt;P, s12);</span>
<span class="lineNum">    1898 </span><span class="lineCov">         88 :     if (!p-&gt;polyline) {</span>
<span class="lineNum">    1899 </span><span class="lineCov">         84 :       accadd(p-&gt;A, S12);</span>
<span class="lineNum">    1900 </span><span class="lineCov">         84 :       p-&gt;crossings += transit(p-&gt;lon, lon);</span>
<span class="lineNum">    1901 </span>            :     }
<span class="lineNum">    1902 </span><span class="lineCov">         88 :     p-&gt;lat = lat; p-&gt;lon = lon;</span>
<span class="lineNum">    1903 </span>            :   }
<span class="lineNum">    1904 </span><span class="lineCov">        126 :   ++p-&gt;num;</span>
<a name="1905"><span class="lineNum">    1905 </span><span class="lineCov">        126 : }</span></a>
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span><span class="lineCov">          6 : void geod_polygon_addedge(const struct geod_geodesic* g,</span>
<span class="lineNum">    1908 </span>            :                           struct geod_polygon* p,
<span class="lineNum">    1909 </span>            :                           real azi, real s) {
<span class="lineNum">    1910 </span><span class="lineCov">          6 :   if (p-&gt;num) {              /* Do nothing is num is zero */</span>
<span class="lineNum">    1911 </span>            :     /* Initialize S12 to stop Visual Studio warning.  Initialization of lat and
<span class="lineNum">    1912 </span>            :      * lon is to make CLang static analyzer happy. */
<span class="lineNum">    1913 </span><span class="lineCov">          6 :     real lat = 0, lon = 0, S12 = 0;</span>
<span class="lineNum">    1914 </span><span class="lineCov">          6 :     geod_gendirect(g, p-&gt;lat, p-&gt;lon, azi, GEOD_LONG_UNROLL, s,</span>
<span class="lineNum">    1915 </span>            :                    &amp;lat, &amp;lon, 0,
<span class="lineNum">    1916 </span><span class="lineCov">          6 :                    0, 0, 0, 0, p-&gt;polyline ? 0 : &amp;S12);</span>
<span class="lineNum">    1917 </span><span class="lineCov">          6 :     accadd(p-&gt;P, s);</span>
<span class="lineNum">    1918 </span><span class="lineCov">          6 :     if (!p-&gt;polyline) {</span>
<span class="lineNum">    1919 </span><span class="lineCov">          6 :       accadd(p-&gt;A, S12);</span>
<span class="lineNum">    1920 </span><span class="lineCov">          6 :       p-&gt;crossings += transitdirect(p-&gt;lon, lon);</span>
<span class="lineNum">    1921 </span>            :     }
<span class="lineNum">    1922 </span><span class="lineCov">          6 :     p-&gt;lat = lat; p-&gt;lon = lon;</span>
<span class="lineNum">    1923 </span><span class="lineCov">          6 :     ++p-&gt;num;</span>
<span class="lineNum">    1924 </span>            :   }
<a name="1925"><span class="lineNum">    1925 </span><span class="lineCov">          6 : }</span></a>
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span><span class="lineCov">         64 : unsigned geod_polygon_compute(const struct geod_geodesic* g,</span>
<span class="lineNum">    1928 </span>            :                               const struct geod_polygon* p,
<span class="lineNum">    1929 </span>            :                               boolx reverse, boolx sign,
<span class="lineNum">    1930 </span>            :                               real* pA, real* pP) {
<span class="lineNum">    1931 </span>            :   real s12, S12, t[2], area0;
<span class="lineNum">    1932 </span>            :   int crossings;
<span class="lineNum">    1933 </span><span class="lineCov">         64 :   if (p-&gt;num &lt; 2) {</span>
<span class="lineNum">    1934 </span><span class="lineCov">         12 :     if (pP) *pP = 0;</span>
<span class="lineNum">    1935 </span><span class="lineCov">         12 :     if (!p-&gt;polyline &amp;&amp; pA) *pA = 0;</span>
<span class="lineNum">    1936 </span><span class="lineCov">         12 :     return p-&gt;num;</span>
<span class="lineNum">    1937 </span>            :   }
<span class="lineNum">    1938 </span><span class="lineCov">         52 :   if (p-&gt;polyline) {</span>
<span class="lineNum">    1939 </span><span class="lineCov">          2 :     if (pP) *pP = p-&gt;P[0];</span>
<span class="lineNum">    1940 </span><span class="lineCov">          2 :     return p-&gt;num;</span>
<span class="lineNum">    1941 </span>            :   }
<span class="lineNum">    1942 </span><span class="lineCov">         50 :   geod_geninverse(g, p-&gt;lat, p-&gt;lon, p-&gt;lat0, p-&gt;lon0,</span>
<span class="lineNum">    1943 </span>            :                   &amp;s12, 0, 0, 0, 0, 0, &amp;S12);
<span class="lineNum">    1944 </span><span class="lineCov">         50 :   if (pP) *pP = accsum(p-&gt;P, s12);</span>
<span class="lineNum">    1945 </span><span class="lineCov">         50 :   acccopy(p-&gt;A, t);</span>
<span class="lineNum">    1946 </span><span class="lineCov">         50 :   accadd(t, S12);</span>
<span class="lineNum">    1947 </span><span class="lineCov">         50 :   crossings = p-&gt;crossings + transit(p-&gt;lon, p-&gt;lon0);</span>
<span class="lineNum">    1948 </span><span class="lineCov">         50 :   area0 = 4 * pi * g-&gt;c2;</span>
<span class="lineNum">    1949 </span><span class="lineCov">         50 :   if (crossings &amp; 1)</span>
<span class="lineNum">    1950 </span><span class="lineCov">         18 :     accadd(t, (t[0] &lt; 0 ? 1 : -1) * area0/2);</span>
<span class="lineNum">    1951 </span>            :   /* area is with the clockwise sense.  If !reverse convert to
<span class="lineNum">    1952 </span>            :    * counter-clockwise convention. */
<span class="lineNum">    1953 </span><span class="lineCov">         50 :   if (!reverse)</span>
<span class="lineNum">    1954 </span><span class="lineCov">         38 :     accneg(t);</span>
<span class="lineNum">    1955 </span>            :   /* If sign put area in (-area0/2, area0/2], else put area in [0, area0) */
<span class="lineNum">    1956 </span><span class="lineCov">         50 :   if (sign) {</span>
<span class="lineNum">    1957 </span><span class="lineCov">         38 :     if (t[0] &gt; area0/2)</span>
<span class="lineNum">    1958 </span><span class="lineCov">          4 :       accadd(t, -area0);</span>
<span class="lineNum">    1959 </span><span class="lineCov">         34 :     else if (t[0] &lt;= -area0/2)</span>
<span class="lineNum">    1960 </span><span class="lineCov">          6 :       accadd(t, +area0);</span>
<span class="lineNum">    1961 </span>            :   } else {
<span class="lineNum">    1962 </span><span class="lineCov">         12 :     if (t[0] &gt;= area0)</span>
<span class="lineNum">    1963 </span><span class="lineCov">          2 :       accadd(t, -area0);</span>
<span class="lineNum">    1964 </span><span class="lineCov">         10 :     else if (t[0] &lt; 0)</span>
<span class="lineNum">    1965 </span><span class="lineCov">          6 :       accadd(t, +area0);</span>
<span class="lineNum">    1966 </span>            :   }
<span class="lineNum">    1967 </span><span class="lineCov">         50 :   if (pA) *pA = 0 + t[0];</span>
<span class="lineNum">    1968 </span><span class="lineCov">         50 :   return p-&gt;num;</span>
<a name="1969"><span class="lineNum">    1969 </span>            : }</a>
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span><span class="lineCov">         34 : unsigned geod_polygon_testpoint(const struct geod_geodesic* g,</span>
<span class="lineNum">    1972 </span>            :                                 const struct geod_polygon* p,
<span class="lineNum">    1973 </span>            :                                 real lat, real lon,
<span class="lineNum">    1974 </span>            :                                 boolx reverse, boolx sign,
<span class="lineNum">    1975 </span>            :                                 real* pA, real* pP) {
<span class="lineNum">    1976 </span>            :   real perimeter, tempsum, area0;
<span class="lineNum">    1977 </span>            :   int crossings, i;
<span class="lineNum">    1978 </span><span class="lineCov">         34 :   unsigned num = p-&gt;num + 1;</span>
<span class="lineNum">    1979 </span><span class="lineCov">         34 :   if (num == 1) {</span>
<span class="lineNum">    1980 </span><span class="lineCov">          8 :     if (pP) *pP = 0;</span>
<span class="lineNum">    1981 </span><span class="lineCov">          8 :     if (!p-&gt;polyline &amp;&amp; pA) *pA = 0;</span>
<span class="lineNum">    1982 </span><span class="lineCov">          8 :     return num;</span>
<span class="lineNum">    1983 </span>            :   }
<span class="lineNum">    1984 </span><span class="lineCov">         26 :   perimeter = p-&gt;P[0];</span>
<span class="lineNum">    1985 </span><span class="lineCov">         26 :   tempsum = p-&gt;polyline ? 0 : p-&gt;A[0];</span>
<span class="lineNum">    1986 </span><span class="lineCov">         26 :   crossings = p-&gt;crossings;</span>
<span class="lineNum">    1987 </span><span class="lineCov">         76 :   for (i = 0; i &lt; (p-&gt;polyline ? 1 : 2); ++i) {</span>
<span class="lineNum">    1988 </span><span class="lineCov">         50 :     real s12, S12 = 0;       /* Initialize S12 to stop Visual Studio warning */</span>
<span class="lineNum">    1989 </span><span class="lineCov">         50 :     geod_geninverse(g,</span>
<span class="lineNum">    1990 </span>            :                     i == 0 ? p-&gt;lat  : lat, i == 0 ? p-&gt;lon  : lon,
<span class="lineNum">    1991 </span>            :                     i != 0 ? p-&gt;lat0 : lat, i != 0 ? p-&gt;lon0 : lon,
<span class="lineNum">    1992 </span><span class="lineCov">         50 :                     &amp;s12, 0, 0, 0, 0, 0, p-&gt;polyline ? 0 : &amp;S12);</span>
<span class="lineNum">    1993 </span><span class="lineCov">         50 :     perimeter += s12;</span>
<span class="lineNum">    1994 </span><span class="lineCov">         50 :     if (!p-&gt;polyline) {</span>
<span class="lineNum">    1995 </span><span class="lineCov">         48 :       tempsum += S12;</span>
<span class="lineNum">    1996 </span><span class="lineCov">         48 :       crossings += transit(i == 0 ? p-&gt;lon  : lon,</span>
<span class="lineNum">    1997 </span>            :                            i != 0 ? p-&gt;lon0 : lon);
<span class="lineNum">    1998 </span>            :     }
<span class="lineNum">    1999 </span>            :   }
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span><span class="lineCov">         26 :   if (pP) *pP = perimeter;</span>
<span class="lineNum">    2002 </span><span class="lineCov">         26 :   if (p-&gt;polyline)</span>
<span class="lineNum">    2003 </span><span class="lineCov">          2 :     return num;</span>
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span><span class="lineCov">         24 :   area0 = 4 * pi * g-&gt;c2;</span>
<span class="lineNum">    2006 </span><span class="lineCov">         24 :   if (crossings &amp; 1)</span>
<span class="lineNum">    2007 </span><span class="lineCov">          8 :     tempsum += (tempsum &lt; 0 ? 1 : -1) * area0/2;</span>
<span class="lineNum">    2008 </span>            :   /* area is with the clockwise sense.  If !reverse convert to
<span class="lineNum">    2009 </span>            :    * counter-clockwise convention. */
<span class="lineNum">    2010 </span><span class="lineCov">         24 :   if (!reverse)</span>
<span class="lineNum">    2011 </span><span class="lineCov">         12 :     tempsum *= -1;</span>
<span class="lineNum">    2012 </span>            :   /* If sign put area in (-area0/2, area0/2], else put area in [0, area0) */
<span class="lineNum">    2013 </span><span class="lineCov">         24 :   if (sign) {</span>
<span class="lineNum">    2014 </span><span class="lineCov">         12 :     if (tempsum &gt; area0/2)</span>
<span class="lineNum">    2015 </span><span class="lineCov">          4 :       tempsum -= area0;</span>
<span class="lineNum">    2016 </span><span class="lineCov">          8 :     else if (tempsum &lt;= -area0/2)</span>
<span class="lineNum">    2017 </span><span class="lineCov">          4 :       tempsum += area0;</span>
<span class="lineNum">    2018 </span>            :   } else {
<span class="lineNum">    2019 </span><span class="lineCov">         12 :     if (tempsum &gt;= area0)</span>
<span class="lineNum">    2020 </span><span class="lineCov">          2 :       tempsum -= area0;</span>
<span class="lineNum">    2021 </span><span class="lineCov">         10 :     else if (tempsum &lt; 0)</span>
<span class="lineNum">    2022 </span><span class="lineCov">          6 :       tempsum += area0;</span>
<span class="lineNum">    2023 </span>            :   }
<span class="lineNum">    2024 </span><span class="lineCov">         24 :   if (pA) *pA = 0 + tempsum;</span>
<span class="lineNum">    2025 </span><span class="lineCov">         24 :   return num;</span>
<a name="2026"><span class="lineNum">    2026 </span>            : }</a>
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span><span class="lineCov">         34 : unsigned geod_polygon_testedge(const struct geod_geodesic* g,</span>
<span class="lineNum">    2029 </span>            :                                const struct geod_polygon* p,
<span class="lineNum">    2030 </span>            :                                real azi, real s,
<span class="lineNum">    2031 </span>            :                                boolx reverse, boolx sign,
<span class="lineNum">    2032 </span>            :                                real* pA, real* pP) {
<span class="lineNum">    2033 </span>            :   real perimeter, tempsum, area0;
<span class="lineNum">    2034 </span>            :   int crossings;
<span class="lineNum">    2035 </span><span class="lineCov">         34 :   unsigned num = p-&gt;num + 1;</span>
<span class="lineNum">    2036 </span><span class="lineCov">         34 :   if (num == 1) {               /* we don't have a starting point! */</span>
<span class="lineNum">    2037 </span><span class="lineCov">          8 :     if (pP) *pP = NaN;</span>
<span class="lineNum">    2038 </span><span class="lineCov">          8 :     if (!p-&gt;polyline &amp;&amp; pA) *pA = NaN;</span>
<span class="lineNum">    2039 </span><span class="lineCov">          8 :     return 0;</span>
<span class="lineNum">    2040 </span>            :   }
<span class="lineNum">    2041 </span><span class="lineCov">         26 :   perimeter = p-&gt;P[0] + s;</span>
<span class="lineNum">    2042 </span><span class="lineCov">         26 :   if (p-&gt;polyline) {</span>
<span class="lineNum">    2043 </span><span class="lineCov">          2 :     if (pP) *pP = perimeter;</span>
<span class="lineNum">    2044 </span><span class="lineCov">          2 :     return num;</span>
<span class="lineNum">    2045 </span>            :   }
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span><span class="lineCov">         24 :   tempsum = p-&gt;A[0];</span>
<span class="lineNum">    2048 </span><span class="lineCov">         24 :   crossings = p-&gt;crossings;</span>
<span class="lineNum">    2049 </span>            :   {
<span class="lineNum">    2050 </span>            :     /* Initialization of lat, lon, and S12 is to make CLang static analyzer
<span class="lineNum">    2051 </span>            :        happy. */
<span class="lineNum">    2052 </span><span class="lineCov">         24 :     real lat = 0, lon = 0, s12, S12 = 0;</span>
<span class="lineNum">    2053 </span><span class="lineCov">         24 :     geod_gendirect(g, p-&gt;lat, p-&gt;lon, azi, GEOD_LONG_UNROLL, s,</span>
<span class="lineNum">    2054 </span>            :                    &amp;lat, &amp;lon, 0,
<span class="lineNum">    2055 </span>            :                    0, 0, 0, 0, &amp;S12);
<span class="lineNum">    2056 </span><span class="lineCov">         24 :     tempsum += S12;</span>
<span class="lineNum">    2057 </span><span class="lineCov">         24 :     crossings += transitdirect(p-&gt;lon, lon);</span>
<span class="lineNum">    2058 </span><span class="lineCov">         24 :     geod_geninverse(g, lat,  lon, p-&gt;lat0,  p-&gt;lon0,</span>
<span class="lineNum">    2059 </span>            :                     &amp;s12, 0, 0, 0, 0, 0, &amp;S12);
<span class="lineNum">    2060 </span><span class="lineCov">         24 :     perimeter += s12;</span>
<span class="lineNum">    2061 </span><span class="lineCov">         24 :     tempsum += S12;</span>
<span class="lineNum">    2062 </span><span class="lineCov">         24 :     crossings += transit(lon, p-&gt;lon0);</span>
<span class="lineNum">    2063 </span>            :   }
<span class="lineNum">    2064 </span>            : 
<span class="lineNum">    2065 </span><span class="lineCov">         24 :   area0 = 4 * pi * g-&gt;c2;</span>
<span class="lineNum">    2066 </span><span class="lineCov">         24 :   if (crossings &amp; 1)</span>
<span class="lineNum">    2067 </span><span class="lineCov">          8 :     tempsum += (tempsum &lt; 0 ? 1 : -1) * area0/2;</span>
<span class="lineNum">    2068 </span>            :   /* area is with the clockwise sense.  If !reverse convert to
<span class="lineNum">    2069 </span>            :    * counter-clockwise convention. */
<span class="lineNum">    2070 </span><span class="lineCov">         24 :   if (!reverse)</span>
<span class="lineNum">    2071 </span><span class="lineCov">         12 :     tempsum *= -1;</span>
<span class="lineNum">    2072 </span>            :   /* If sign put area in (-area0/2, area0/2], else put area in [0, area0) */
<span class="lineNum">    2073 </span><span class="lineCov">         24 :   if (sign) {</span>
<span class="lineNum">    2074 </span><span class="lineCov">         12 :     if (tempsum &gt; area0/2)</span>
<span class="lineNum">    2075 </span><span class="lineCov">          4 :       tempsum -= area0;</span>
<span class="lineNum">    2076 </span><span class="lineCov">          8 :     else if (tempsum &lt;= -area0/2)</span>
<span class="lineNum">    2077 </span><span class="lineCov">          4 :       tempsum += area0;</span>
<span class="lineNum">    2078 </span>            :   } else {
<span class="lineNum">    2079 </span><span class="lineCov">         12 :     if (tempsum &gt;= area0)</span>
<span class="lineNum">    2080 </span><span class="lineCov">          2 :       tempsum -= area0;</span>
<span class="lineNum">    2081 </span><span class="lineCov">         10 :     else if (tempsum &lt; 0)</span>
<span class="lineNum">    2082 </span><span class="lineCov">          6 :       tempsum += area0;</span>
<span class="lineNum">    2083 </span>            :   }
<span class="lineNum">    2084 </span><span class="lineCov">         24 :   if (pP) *pP = perimeter;</span>
<span class="lineNum">    2085 </span><span class="lineCov">         24 :   if (pA) *pA = 0 + tempsum;</span>
<span class="lineNum">    2086 </span><span class="lineCov">         24 :   return num;</span>
<a name="2087"><span class="lineNum">    2087 </span>            : }</a>
<span class="lineNum">    2088 </span>            : 
<span class="lineNum">    2089 </span><span class="lineCov">          2 : void geod_polygonarea(const struct geod_geodesic* g,</span>
<span class="lineNum">    2090 </span>            :                       real lats[], real lons[], int n,
<span class="lineNum">    2091 </span>            :                       real* pA, real* pP) {
<span class="lineNum">    2092 </span>            :   int i;
<span class="lineNum">    2093 </span>            :   struct geod_polygon p;
<span class="lineNum">    2094 </span><span class="lineCov">          2 :   geod_polygon_init(&amp;p, FALSE);</span>
<span class="lineNum">    2095 </span><span class="lineCov">          8 :   for (i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    2096 </span><span class="lineCov">          6 :     geod_polygon_addpoint(g, &amp;p, lats[i], lons[i]);</span>
<span class="lineNum">    2097 </span><span class="lineCov">          2 :   geod_polygon_compute(g, &amp;p, FALSE, TRUE, pA, pP);</span>
<span class="lineNum">    2098 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span>            : /** @endcond */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
