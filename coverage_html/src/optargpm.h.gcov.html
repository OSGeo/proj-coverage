<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - proj.info - src/optargpm.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - optargpm.h<span style="font-size: 80%;"> (source / <a href="optargpm.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">proj.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">81</td>
            <td class="headerCovTableEntry">238</td>
            <td class="headerCovTableEntryLo">34.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-06-07 22:42:34</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">45.5 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /***********************************************************************</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            :           OPTARGPM - a header-only library for decoding
<span class="lineNum">       4 </span>            :                 PROJ.4 style command line options
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :                    Thomas Knudsen, 2017-09-10
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : ************************************************************************
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : For PROJ.4 command line programs, we have a somewhat complex option
<span class="lineNum">      11 </span>            : decoding situation, since we have to navigate in a cocktail of classic
<span class="lineNum">      12 </span>            : single letter style options, prefixed by &quot;-&quot;, GNU style long options
<span class="lineNum">      13 </span>            : prefixed by &quot;--&quot;, transformation specification elements prefixed by &quot;+&quot;,
<span class="lineNum">      14 </span>            : and input file names prefixed by &quot;&quot; (i.e. nothing).
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : Hence, classic getopt.h style decoding does not cut the mustard, so
<span class="lineNum">      17 </span>            : this is an attempt to catch up and chop the ketchup.
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : Since optargpm (for &quot;optarg plus minus&quot;) does not belong, in any
<span class="lineNum">      20 </span>            : obvious way, in any systems development library, it is provided as
<span class="lineNum">      21 </span>            : a &quot;header only&quot; library.
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : While this is conventional in C++, it is frowned at in plain C.
<span class="lineNum">      24 </span>            : But frown away - &quot;header only&quot; has its places, and this is one of
<span class="lineNum">      25 </span>            : them.
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : By convention, we expect a command line to consist of the following
<span class="lineNum">      28 </span>            : elements:
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            :         &lt;operator/program name&gt;
<span class="lineNum">      31 </span>            :         [short (&quot;-&quot;)/long (&quot;--&quot;) options}
<span class="lineNum">      32 </span>            :         [operator (&quot;+&quot;) specs]
<span class="lineNum">      33 </span>            :         [operands/input files]
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : or less verbose:
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            :         &lt;operator&gt;   [options]   [operator specs]   [operands]
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : or less abstract:
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :    proj  -I --output=foo  +proj=utm +zone=32 +ellps=GRS80   bar baz...
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : Where
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : Operator is              proj
<span class="lineNum">      46 </span>            : Options are             -I --output=foo
<span class="lineNum">      47 </span>            : Operator specs are      +proj=utm +zone=32 +ellps=GRS80
<span class="lineNum">      48 </span>            : Operands are             bar baz
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : While neither claiming to save the world, nor to hint at the &quot;shape of
<span class="lineNum">      52 </span>            : jazz to come&quot;, at least optargpm has shown useful in constructing cs2cs
<span class="lineNum">      53 </span>            : style transformation filters.
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : Supporting a wide range of option syntax, the getoptpm API is somewhat
<span class="lineNum">      56 </span>            : quirky, but also compact, consisting of one data type, 3(+2) functions,
<span class="lineNum">      57 </span>            : and one enumeration:
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : OPTARGS
<span class="lineNum">      60 </span>            :         Housekeeping data type. An instance of OPTARGS is conventionally
<span class="lineNum">      61 </span>            :         called o or opt
<span class="lineNum">      62 </span>            : opt_parse (opt, argc, argv ...):
<span class="lineNum">      63 </span>            :         The work horse: Define supported options; Split (argc, argv)
<span class="lineNum">      64 </span>            :         into groups (options, op specs, operands); Parse option
<span class="lineNum">      65 </span>            :         arguments.
<span class="lineNum">      66 </span>            : opt_given (o, option):
<span class="lineNum">      67 </span>            :         The number of times &lt;option&gt; was given on the command line.
<span class="lineNum">      68 </span>            :         (i.e. 0 if not given or option unsupported)
<span class="lineNum">      69 </span>            : opt_arg (o, option):
<span class="lineNum">      70 </span>            :         A char pointer to the argument for &lt;option&gt;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : The 2 additional functions (of which, one is really a macro) implements
<span class="lineNum">      73 </span>            : a &quot;read all operands sequentially&quot; functionality, eliminating the need to
<span class="lineNum">      74 </span>            : handle open/close of a sequence of input files:
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : enum OPTARGS_FILE_MODE:
<span class="lineNum">      77 </span>            :         indicates whether to read operands in text (0) or binary (1) mode
<span class="lineNum">      78 </span>            : opt_input_loop (o, mode):
<span class="lineNum">      79 </span>            :         When used as condition in a while loop, traverses all operands,
<span class="lineNum">      80 </span>            :         giving the impression of reading just a single input file.
<span class="lineNum">      81 </span>            : opt_eof_handler (o):
<span class="lineNum">      82 </span>            :         Auxiliary macro, to be called inside the input loop after each
<span class="lineNum">      83 </span>            :         read operation
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : Usage is probably easiest understood by a brief textbook style example:
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : Consider a simple program taking the conventional &quot;-v, -h, -o&quot; options
<span class="lineNum">      88 </span>            : indicating &quot;verbose output&quot;, &quot;help please&quot;, and &quot;output file specification&quot;,
<span class="lineNum">      89 </span>            : respectively.
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : The &quot;-v&quot; and &quot;-h&quot; options are *flags*, taking no arguments, while the
<span class="lineNum">      92 </span>            : &quot;-o&quot; option is a *key*, taking a *value* argument, representing the
<span class="lineNum">      93 </span>            : output file name.
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : The short options have long aliases: &quot;--verbose&quot;, &quot;--help&quot; and &quot;--output&quot;.
<span class="lineNum">      96 </span>            : Additionally, the long key &quot;--hello&quot;, without any short counterpart, is
<span class="lineNum">      97 </span>            : supported.
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : -------------------------------------------------------------------------------
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : int main(int argc, char **argv) {
<span class="lineNum">     103 </span>            :     PJ *P;
<span class="lineNum">     104 </span>            :     OPTARGS *o;
<span class="lineNum">     105 </span>            :     FILE *out = stdout;
<span class="lineNum">     106 </span>            :     char *longflags[]  = {&quot;v=verbose&quot;, &quot;h=help&quot;, 0};
<span class="lineNum">     107 </span>            :     char *longkeys[]   = {&quot;o=output&quot;, &quot;hello&quot;, 0};
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :     o = opt_parse (argc, argv, &quot;hv&quot;, &quot;o&quot;, longflags, longkeys);
<span class="lineNum">     110 </span>            :     if (0==o)
<span class="lineNum">     111 </span>            :         return 0;
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :     if (opt_given (o, &quot;h&quot;)) {
<span class="lineNum">     115 </span>            :         printf (&quot;Usage: %s [-v|--verbose] [-h|--help] [-o|--output &lt;filename&gt;] [--hello=&lt;name&gt;] infile...&quot;, o-&gt;progname);
<span class="lineNum">     116 </span>            :         exit (0);
<span class="lineNum">     117 </span>            :     }
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            :     if (opt_given (o, &quot;v&quot;))
<span class="lineNum">     120 </span>            :         puts (&quot;Feeling chatty today?&quot;);
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     if (opt_given (o, &quot;hello&quot;)) {
<span class="lineNum">     123 </span>            :         printf (&quot;Hello, %s!\n&quot;, opt_arg(o, &quot;hello&quot;));
<span class="lineNum">     124 </span>            :         exit (0);
<span class="lineNum">     125 </span>            :     }
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :     if (opt_given (o, &quot;o&quot;))
<span class="lineNum">     128 </span>            :         out = fopen (opt_arg (o, &quot;output&quot;), &quot;rt&quot;); // Note: &quot;output&quot; translates to &quot;o&quot; internally
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :     // Setup transformation
<span class="lineNum">     131 </span>            :     P = proj_create_argv (0, o-&gt;pargc, o-&gt;pargv);
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :     // Loop over all lines of all input files
<span class="lineNum">     134 </span>            :     while (opt_input_loop (o, optargs_file_format_text)) {
<span class="lineNum">     135 </span>            :         char buf[1000];
<span class="lineNum">     136 </span>            :         int ret = fgets (buf, 1000, o-&gt;input);
<span class="lineNum">     137 </span>            :         opt_eof_handler (o);
<span class="lineNum">     138 </span>            :         if (0==ret) {
<span class="lineNum">     139 </span>            :             fprintf (stderr, &quot;Read error in record %d\n&quot;, (int) o-&gt;record_index);
<span class="lineNum">     140 </span>            :             continue;
<span class="lineNum">     141 </span>            :         }
<span class="lineNum">     142 </span>            :         do_what_needs_to_be_done (buf);
<span class="lineNum">     143 </span>            :     }
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :     return 0;
<span class="lineNum">     146 </span>            : }
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : -------------------------------------------------------------------------------
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : Note how short aliases for longflags and longkeys are defined by prefixing
<span class="lineNum">     152 </span>            : an &quot;o=&quot;, &quot;h=&quot; or &quot;v=&quot;, respectively. This also means that it is possible to
<span class="lineNum">     153 </span>            : have more than one alias for each short option, e.g.
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :                longkeys = {&quot;o=output&quot;, &quot;o=banana&quot;, 0}
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : would define both &quot;--output&quot; and &quot;--banana&quot; to be aliases for &quot;-o&quot;.
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            : ************************************************************************
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : Thomas Knudsen, thokn@sdfe.dk, 2016-05-25/2017-09-10
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : ************************************************************************
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : * Copyright (c) 2016, 2017 Thomas Knudsen
<span class="lineNum">     166 </span>            : *
<span class="lineNum">     167 </span>            : * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">     168 </span>            : * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">     169 </span>            : * to deal in the Software without restriction, including without limitation
<span class="lineNum">     170 </span>            : * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">     171 </span>            : * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">     172 </span>            : * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">     173 </span>            : *
<span class="lineNum">     174 </span>            : * The above copyright notice and this permission notice shall be included
<span class="lineNum">     175 </span>            : * in all copies or substantial portions of the Software.
<span class="lineNum">     176 </span>            : *
<span class="lineNum">     177 </span>            : * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
<span class="lineNum">     178 </span>            : * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">     179 </span>            : * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
<span class="lineNum">     180 </span>            : * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">     181 </span>            : * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">     182 </span>            : * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
<span class="lineNum">     183 </span>            : * DEALINGS IN THE SOFTWARE.
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : ***********************************************************************/
<span class="lineNum">     186 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">     187 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">     188 </span>            : #include &lt;math.h&gt;
<span class="lineNum">     189 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">     190 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">     191 </span>            : #include &lt;string.h&gt;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : /**************************************************************************************************/
<span class="lineNum">     194 </span>            : struct OPTARGS;
<span class="lineNum">     195 </span>            : typedef struct OPTARGS OPTARGS;
<span class="lineNum">     196 </span>            : enum OPTARGS_FILE_FORMAT {optargs_file_format_text = 0, optargs_file_format_binary = 1};
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : char *opt_filename (OPTARGS *opt);
<span class="lineNum">     199 </span>            : static int opt_eof (OPTARGS *opt);
<span class="lineNum">     200 </span>            : int opt_record (OPTARGS *opt);
<span class="lineNum">     201 </span>            : int opt_input_loop (OPTARGS *opt, int binary);
<span class="lineNum">     202 </span>            : static int opt_is_flag (OPTARGS *opt, int ordinal);
<span class="lineNum">     203 </span>            : static int opt_raise_flag (OPTARGS *opt, int ordinal);
<span class="lineNum">     204 </span>            : static int opt_ordinal (OPTARGS *opt, char *option);
<span class="lineNum">     205 </span>            : int opt_given (OPTARGS *opt, char *option);
<span class="lineNum">     206 </span>            : char *opt_arg (OPTARGS *opt, char *option);
<span class="lineNum">     207 </span>            : const char *opt_strip_path (const char *full_name);
<span class="lineNum">     208 </span>            : OPTARGS *opt_parse (int argc, char **argv, const char *flags, const char *keys, const char **longflags, const char **longkeys);
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : #define opt_eof_handler(opt) if (opt_eof (opt)) {continue;} else {;}
<span class="lineNum">     211 </span>            : /**************************************************************************************************/
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : struct OPTARGS {
<span class="lineNum">     214 </span>            :     int    argc,   margc,   pargc,   fargc;
<span class="lineNum">     215 </span>            :     char **argv, **margv, **pargv, **fargv;
<span class="lineNum">     216 </span>            :     FILE *input;
<span class="lineNum">     217 </span>            :     int   input_index;
<span class="lineNum">     218 </span>            :     int   record_index;
<span class="lineNum">     219 </span>            :     const char  *progname;   /* argv[0], stripped from /path/to, if present */
<span class="lineNum">     220 </span>            :     char   flaglevel[21];    /* if flag -f is specified n times, its optarg pointer is set to flaglevel + n */
<span class="lineNum">     221 </span>            :     char  *optarg[256];      /* optarg[(int) 'f'] holds a pointer to the argument of option &quot;-f&quot; */
<span class="lineNum">     222 </span>            :     char  *flags;            /* a list of flag style options supported, e.g. &quot;hv&quot; (help and verbose) */
<span class="lineNum">     223 </span>            :     char  *keys;             /* a list of key/value style options supported, e.g. &quot;o&quot; (output) */
<span class="lineNum">     224 </span>            :     const char **longflags;  /* long flags, {&quot;help&quot;, &quot;verbose&quot;}, or {&quot;h=help&quot;, &quot;v=verbose&quot;}, to indicate homologous short options */
<span class="lineNum">     225 </span>            :     const char **longkeys;   /* e.g. {&quot;output&quot;} or {o=output&quot;} to support --output=/path/to/output-file. In the latter case, */
<span class="lineNum">     226 </span>            :                              /* all operations on &quot;--output&quot; gets redirected to &quot;-o&quot;, so user code need handle arguments to &quot;-o&quot; only */
<span class="lineNum">     227 </span>            : };
<span class="lineNum">     228 </span>            : 
<a name="229"><span class="lineNum">     229 </span>            : </a>
<span class="lineNum">     230 </span>            : /* name of file currently read from */
<span class="lineNum">     231 </span><span class="lineNoCov">          0 : char *opt_filename (OPTARGS *opt) {</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     if (0==opt)</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     if (0==opt-&gt;fargc)</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         return opt-&gt;flaglevel;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     return opt-&gt;fargv[opt-&gt;input_index];</span>
<a name="237"><span class="lineNum">     237 </span>            : }</a>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 : static int opt_eof (OPTARGS *opt) {</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     if (0==opt)</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     return feof (opt-&gt;input);</span>
<span class="lineNum">     243 </span>            : }
<a name="244"><span class="lineNum">     244 </span>            : </a>
<span class="lineNum">     245 </span>            : /* record number of most recently read record */
<span class="lineNum">     246 </span><span class="lineNoCov">          0 : int opt_record (OPTARGS *opt) {</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     if (0==opt)</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     return opt-&gt;record_index + 1;</span>
<span class="lineNum">     250 </span>            : }
<span class="lineNum">     251 </span>            : 
<a name="252"><span class="lineNum">     252 </span>            : </a>
<span class="lineNum">     253 </span>            : /* handle closing/opening of a &quot;stream-of-streams&quot; */
<span class="lineNum">     254 </span><span class="lineNoCov">          0 : int opt_input_loop (OPTARGS *opt, int binary) {</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     if (0==opt)</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :     /* most common case: increment record index and read on */
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     if ( (opt-&gt;input!=0) &amp;&amp; !feof (opt-&gt;input) ) {</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         opt-&gt;record_index++;</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     262 </span>            :     }
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     opt-&gt;record_index = 0;</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :     /* no input files specified - read from stdin */
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     if ((0==opt-&gt;fargc) &amp;&amp; (0==opt-&gt;input)) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         opt-&gt;input = stdin;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     270 </span>            :     }
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :     /* if we're here, we have either reached eof on current input file.   */
<span class="lineNum">     273 </span>            :     /*  or not yet opened a file. If eof on stdin, we're done             */
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     if (opt-&gt;input==stdin)</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :     /* end if no more input */
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     if (0!=opt-&gt;input)</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         fclose (opt-&gt;input);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     if (opt-&gt;input_index &gt;= opt-&gt;fargc)</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :     /* otherwise, open next input file */
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     opt-&gt;input = fopen (opt-&gt;fargv[opt-&gt;input_index++], binary? &quot;rb&quot;: &quot;rt&quot;);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     if (0 != opt-&gt;input)</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :     /* ignore non-existing files - go on! */
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     if (0==opt-&gt;input)</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         return opt_input_loop (opt, binary);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     292 </span>            : }
<span class="lineNum">     293 </span>            : 
<a name="294"><span class="lineNum">     294 </span>            : </a>
<span class="lineNum">     295 </span>            : /* return true if option with given ordinal is a flag, false if undefined or key=value */
<span class="lineNum">     296 </span><span class="lineCov">        157 : static int opt_is_flag (OPTARGS *opt, int ordinal) {</span>
<span class="lineNum">     297 </span><span class="lineCov">        157 :     if (opt-&gt;optarg[ordinal] &lt; opt-&gt;flaglevel)</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     299 </span><span class="lineCov">        157 :     if (opt-&gt;optarg[ordinal] &gt; opt-&gt;flaglevel + 20)</span>
<span class="lineNum">     300 </span><span class="lineCov">         26 :         return 0;</span>
<span class="lineNum">     301 </span><span class="lineCov">        131 :     return 1;</span>
<a name="302"><span class="lineNum">     302 </span>            : }</a>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span><span class="lineNoCov">          0 : static int opt_raise_flag (OPTARGS *opt, int ordinal) {</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     if (opt-&gt;optarg[ordinal] &lt; opt-&gt;flaglevel)</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     if (opt-&gt;optarg[ordinal] &gt; opt-&gt;flaglevel + 20)</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :     /* Max out at 20 */
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     if (opt-&gt;optarg[ordinal]==opt-&gt;flaglevel + 20)</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     opt-&gt;optarg[ordinal]++;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     315 </span>            : }
<a name="316"><span class="lineNum">     316 </span>            : </a>
<span class="lineNum">     317 </span>            : /* Find the ordinal value of any (short or long) option */
<span class="lineNum">     318 </span><span class="lineCov">        157 : static int opt_ordinal (OPTARGS *opt, char *option) {</span>
<span class="lineNum">     319 </span>            :     int i;
<span class="lineNum">     320 </span><span class="lineCov">        157 :     if (0==opt)</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     322 </span><span class="lineCov">        157 :     if (0==option)</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     324 </span><span class="lineCov">        157 :     if (0==option[0])</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     326 </span>            :     /* An ordinary -o style short option */
<span class="lineNum">     327 </span><span class="lineCov">        157 :     if (strlen (option)==1) {</span>
<span class="lineNum">     328 </span>            :         /* Undefined option? */
<span class="lineNum">     329 </span><span class="lineCov">        131 :         if (0==opt-&gt;optarg[(int) option[0]])</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     331 </span><span class="lineCov">        131 :         return (int) option[0];</span>
<span class="lineNum">     332 </span>            :     }
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :     /* --longname style long options are slightly harder */
<span class="lineNum">     335 </span><span class="lineCov">        130 :     for (i = 0; i &lt; 64; i++) {</span>
<span class="lineNum">     336 </span><span class="lineCov">        130 :         const char **f = opt-&gt;longflags;</span>
<span class="lineNum">     337 </span><span class="lineCov">        130 :         if (0==f)</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     339 </span><span class="lineCov">        130 :         if (0==f[i])</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     341 </span><span class="lineCov">        130 :         if (0==strcmp(f[i], &quot;END&quot;))</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     343 </span><span class="lineCov">        130 :         if (0==strcmp(f[i], option))</span>
<span class="lineNum">     344 </span><span class="lineCov">         26 :             return 128 + i;</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            :         /* long alias? - return ordinal for corresponding short */
<span class="lineNum">     347 </span><span class="lineCov">        104 :         if ((strlen(f[i]) &gt; 2) &amp;&amp; (f[i][1]=='=') &amp;&amp; (0==strcmp(f[i]+2, option))) {</span>
<span class="lineNum">     348 </span>            :                 /* Undefined option? */
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :                 if (0==opt-&gt;optarg[(int) f[i][0]])</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :                     return 0;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                 return (int) f[i][0];</span>
<span class="lineNum">     352 </span>            :         }
<span class="lineNum">     353 </span>            :     }
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; 64; i++) {</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         const char **v = opt-&gt;longkeys;</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         if (0==v)</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         if (0==v[i])</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         if (0==strcmp (v[i], &quot;END&quot;))</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         if (0==strcmp(v[i], option))</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :             return 192 + i;</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :         /* long alias? - return ordinal for corresponding short */
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         if ((strlen(v[i]) &gt; 2) &amp;&amp; (v[i][1]=='=') &amp;&amp; (0==strcmp(v[i]+2, option))) {</span>
<span class="lineNum">     368 </span>            :             /* Undefined option? */
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :             if (0==opt-&gt;optarg[(int) v[i][0]])</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :             return (int) v[i][0];</span>
<span class="lineNum">     372 </span>            :         }
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :     }
<span class="lineNum">     375 </span>            :     /* kill some potential compiler warnings about unused functions */
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     (void) opt_eof (0);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     378 </span>            : }
<span class="lineNum">     379 </span>            : 
<a name="380"><span class="lineNum">     380 </span>            : </a>
<span class="lineNum">     381 </span>            : /* Returns 0 if option was not given on command line, non-0 otherwise */
<span class="lineNum">     382 </span><span class="lineCov">        157 : int opt_given (OPTARGS *opt, char *option) {</span>
<span class="lineNum">     383 </span><span class="lineCov">        157 :     int ordinal = opt_ordinal (opt, option);</span>
<span class="lineNum">     384 </span><span class="lineCov">        157 :     if (0==ordinal)</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     386 </span>            :     /* For flags we return the number of times the flag was specified (mostly for repeated -v(erbose) flags) */
<span class="lineNum">     387 </span><span class="lineCov">        157 :     if (opt_is_flag (opt, ordinal))</span>
<span class="lineNum">     388 </span><span class="lineCov">        131 :         return (int) (opt-&gt;optarg[ordinal] - opt-&gt;flaglevel);</span>
<span class="lineNum">     389 </span><span class="lineCov">         26 :     return opt-&gt;argv[0] != opt-&gt;optarg[ordinal];</span>
<span class="lineNum">     390 </span>            : }
<span class="lineNum">     391 </span>            : 
<a name="392"><span class="lineNum">     392 </span>            : </a>
<span class="lineNum">     393 </span>            : /* Returns the argument to a given option */
<span class="lineNum">     394 </span><span class="lineNoCov">          0 : char *opt_arg (OPTARGS *opt, char *option) {</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     int ordinal = opt_ordinal (opt, option);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     if (0==ordinal)</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     return opt-&gt;optarg[ordinal];</span>
<a name="399"><span class="lineNum">     399 </span>            : }</a>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineCov">         28 : const char *opt_strip_path (const char *full_name) {</span>
<span class="lineNum">     402 </span><span class="lineCov">         28 :     const char *last_path_delim, *stripped_name = full_name;</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineCov">         28 :     last_path_delim = strrchr (stripped_name, '\\');</span>
<span class="lineNum">     405 </span><span class="lineCov">         28 :     if (last_path_delim &gt; stripped_name)</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :         stripped_name = last_path_delim + 1;</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineCov">         28 :     last_path_delim = strrchr (stripped_name, '/');</span>
<span class="lineNum">     409 </span><span class="lineCov">         28 :     if (last_path_delim &gt; stripped_name)</span>
<span class="lineNum">     410 </span><span class="lineCov">         28 :         stripped_name = last_path_delim + 1;</span>
<span class="lineNum">     411 </span><span class="lineCov">         28 :     return stripped_name;</span>
<span class="lineNum">     412 </span>            : }
<a name="413"><span class="lineNum">     413 </span>            : </a>
<span class="lineNum">     414 </span>            : /* split command line options into options/flags (&quot;-&quot; style), projdefs (&quot;+&quot; style) and input file args */
<span class="lineNum">     415 </span><span class="lineCov">         27 : OPTARGS *opt_parse (int argc, char **argv, const char *flags, const char *keys, const char **longflags, const char **longkeys) {</span>
<span class="lineNum">     416 </span>            :     int i, j;
<span class="lineNum">     417 </span>            :     int free_format;
<span class="lineNum">     418 </span>            :     OPTARGS *o;
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineCov">         27 :     o = (OPTARGS *) calloc (1, sizeof(OPTARGS));</span>
<span class="lineNum">     421 </span><span class="lineCov">         27 :     if (0==o)</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">         27 :     o-&gt;argc = argc;</span>
<span class="lineNum">     425 </span><span class="lineCov">         27 :     o-&gt;argv = argv;</span>
<span class="lineNum">     426 </span><span class="lineCov">         27 :     o-&gt;progname = opt_strip_path (argv[0]);</span>
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            :     /* Reset all flags */
<span class="lineNum">     429 </span><span class="lineCov">        135 :     for (i = 0;  i &lt; (int) strlen (flags);  i++)</span>
<span class="lineNum">     430 </span><span class="lineCov">        108 :         o-&gt;optarg[(int) flags[i]] = o-&gt;flaglevel;</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :      /* Flag args for all argument taking options as &quot;unset&quot; */
<span class="lineNum">     433 </span><span class="lineCov">         54 :     for (i = 0; i &lt; (int) strlen (keys); i++)</span>
<span class="lineNum">     434 </span><span class="lineCov">         27 :         o-&gt;optarg[(int) keys[i]] = argv[0];</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :     /* Hence, undefined/illegal options have an argument of 0 */
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :     /* long opts are handled similarly, but are mapped to the high bit character range (above 128) */
<span class="lineNum">     439 </span><span class="lineCov">         27 :     o-&gt;longflags  =  longflags;</span>
<span class="lineNum">     440 </span><span class="lineCov">         27 :     o-&gt;longkeys   =  longkeys;</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :     /* check aliases, An end user should never experience this, but */
<span class="lineNum">     444 </span>            :     /* the developer should make sure that aliases are valid */
<span class="lineNum">     445 </span><span class="lineCov">        162 :     for (i = 0;  longflags &amp;&amp; longflags[i]; i++) {</span>
<span class="lineNum">     446 </span>            :         /* Go on if it does not look like an alias */
<span class="lineNum">     447 </span><span class="lineCov">        135 :         if (strlen (longflags[i]) &lt; 3)</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     449 </span><span class="lineCov">        135 :         if ('='!=longflags[i][1])</span>
<span class="lineNum">     450 </span><span class="lineCov">         27 :             continue;</span>
<span class="lineNum">     451 </span><span class="lineCov">        108 :         if (0==strchr (flags, longflags[i][0])) {</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :             fprintf (stderr, &quot;%s: Invalid alias - '%s'. Valid short flags are '%s'\n&quot;, o-&gt;progname, longflags[i], flags);</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :             free (o);</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     455 </span>            :         }
<span class="lineNum">     456 </span>            :     }
<span class="lineNum">     457 </span><span class="lineCov">         54 :     for (i = 0;  longkeys &amp;&amp; longkeys[i]; i++) {</span>
<span class="lineNum">     458 </span>            :         /* Go on if it does not look like an alias */
<span class="lineNum">     459 </span><span class="lineCov">         27 :         if (strlen (longkeys[i]) &lt; 3)</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     461 </span><span class="lineCov">         27 :         if ('='!=longkeys[i][1])</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     463 </span><span class="lineCov">         27 :         if (0==strchr (keys, longkeys[i][0])) {</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :             fprintf (stderr, &quot;%s: Invalid alias - '%s'. Valid short flags are '%s'\n&quot;, o-&gt;progname, longkeys[i], keys);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             free (o);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     467 </span>            :         }
<span class="lineNum">     468 </span>            :     }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :     /* aside from counting the number of times a flag has been specified, we also abuse the */
<span class="lineNum">     471 </span>            :     /* flaglevel array to provide a pseudo-filename for the case of reading from stdin      */
<span class="lineNum">     472 </span><span class="lineCov">         27 :     strcpy (o-&gt;flaglevel, &quot;&lt;stdin&gt;&quot;);</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineCov">        162 :     for (i = 128; (longflags != 0) &amp;&amp; (longflags[i - 128] != 0); i++) {</span>
<span class="lineNum">     475 </span><span class="lineCov">        135 :         if (i==192) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :             free (o);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :             fprintf (stderr, &quot;Too many flag style long options\n&quot;);</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     479 </span>            :         }
<span class="lineNum">     480 </span><span class="lineCov">        135 :         o-&gt;optarg[i] = o-&gt;flaglevel;</span>
<span class="lineNum">     481 </span>            :     }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineCov">         54 :     for (i = 192;  (longkeys != 0) &amp;&amp; (longkeys[i - 192] != 0);  i++) {</span>
<span class="lineNum">     484 </span><span class="lineCov">         27 :         if (i==256) {</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :             free (o);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :             fprintf (stderr, &quot;Too many value style long options\n&quot;);</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     488 </span>            :         }
<span class="lineNum">     489 </span><span class="lineCov">         27 :         o-&gt;optarg[i] = argv[0];</span>
<span class="lineNum">     490 </span>            :     }
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :     /* Now, set up the agrc/argv pairs, and interpret args */
<span class="lineNum">     493 </span><span class="lineCov">         27 :     o-&gt;argc = argc;</span>
<span class="lineNum">     494 </span><span class="lineCov">         27 :     o-&gt;argv = argv;</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :     /* Process all '-' and '--'-style options */
<span class="lineNum">     497 </span><span class="lineCov">         27 :     for (i = 1;  i &lt; argc;  i++) {</span>
<span class="lineNum">     498 </span><span class="lineCov">         26 :         int arg_group_size = (int) strlen (argv[i]);</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineCov">         26 :         if ('-' != argv[i][0])</span>
<span class="lineNum">     501 </span><span class="lineCov">         26 :             break;</span>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         if (0==o-&gt;margv)</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :             o-&gt;margv = argv + i;</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :         o-&gt;margc++;</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         for (j = 1;  j &lt; arg_group_size;  j++) {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :             int c =  argv[i][j];</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :             char cstring[2], *crepr = cstring;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :             cstring[0] = (char) c;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :             cstring[1] = 0;</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :             /* Long style flags and options (--long_opt_name, --long_opt_namr arg, --long_opt_name=arg) */
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :             if (c== (int)'-') {</span>
<span class="lineNum">     516 </span>            :                 char *equals;
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                 crepr = argv[i] + 2;</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :                 /* We need to manipulate a bit to support gnu style --foo=bar syntax.   */
<span class="lineNum">     520 </span>            :                 /* NOTE: This will segfault for read-only (const char * style) storage, */
<span class="lineNum">     521 </span>            :                 /* but since the canonical use case, int main (int argc, char **argv),  */
<span class="lineNum">     522 </span>            :                 /* is non-const, we ignore this for now */
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                 equals = strchr (crepr, '=');</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                 if (equals)</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                     *equals = 0;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                 c = opt_ordinal (o, crepr);</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                 if (0==c) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                     fprintf (stderr, &quot;Invalid option \&quot;%s\&quot;\n&quot;, crepr);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                     return (OPTARGS *) 0;</span>
<span class="lineNum">     530 </span>            :                 }
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :                 /* inline (gnu) --foo=bar style arg */
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                 if (equals) {</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                     *equals = '=';</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :                     if (opt_is_flag (o, c)) {</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :                         fprintf (stderr, &quot;Option \&quot;%s\&quot; takes no arguments\n&quot;, crepr);</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :                         return (OPTARGS *) 0;</span>
<span class="lineNum">     538 </span>            :                     }
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :                     o-&gt;optarg[c] = equals + 1;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     541 </span>            :                 }
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :                 /* &quot;outline&quot; --foo bar style arg */
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                 if (!opt_is_flag (o, c)) {</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                     if ((argc==i + 1) || ('+'==argv[i+1][0]) || ('-'==argv[i+1][0])) {</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :                         fprintf (stderr, &quot;Missing argument for option \&quot;%s\&quot;\n&quot;, crepr);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                         return (OPTARGS *) 0;</span>
<span class="lineNum">     548 </span>            :                     }
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                     o-&gt;optarg[c] = argv[i + 1];</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :                     i++; /* eat the arg */</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     552 </span>            :                 }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :                 if (!opt_is_flag (o, c)) {</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :                     fprintf (stderr, &quot;Expected flag style long option here, but got \&quot;%s\&quot;\n&quot;, crepr);</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :                     return (OPTARGS *) 0;</span>
<span class="lineNum">     557 </span>            :                 }
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            :                 /* Flag style option, i.e. taking no arguments */
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :                 opt_raise_flag (o, c);</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     562 </span>            :             }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :             /* classic short options */
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :             if (0==o-&gt;optarg[c]) {</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :                 fprintf (stderr, &quot;Invalid option \&quot;%s\&quot;\n&quot;, crepr);</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                 return (OPTARGS *) 0;</span>
<span class="lineNum">     568 </span>            :             }
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :             /* Flag style option, i.e. taking no arguments */
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :             if (opt_is_flag (o, c)) {</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :                 opt_raise_flag (o, c);</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     574 </span>            :             }
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :             /* options taking argumants */
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :             /* argument separate (i.e. &quot;-i 10&quot;) */
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :             if (j + 1==arg_group_size) {</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :                 if ((argc==i + 1) || ('+'==argv[i+1][0]) || ('-'==argv[i+1][0]))</span>
<span class="lineNum">     581 </span>            :                 {
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :                     fprintf (stderr, &quot;Bad or missing arg for option \&quot;%s\&quot;\n&quot;, crepr);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                     return (OPTARGS *) 0;</span>
<span class="lineNum">     584 </span>            :                 }
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :                 o-&gt;optarg[(int) c] = argv[i + 1];</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :                 i++;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     588 </span>            :             }
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :             /* Option arg inline (i.e. &quot;-i10&quot;) */
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :             o-&gt;optarg[c] = argv[i] + j + 1;</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     593 </span>            :         }
<span class="lineNum">     594 </span>            :     }
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            :     /* Process all '+'-style options, starting from where '-'-style processing ended */
<span class="lineNum">     597 </span><span class="lineCov">         27 :     o-&gt;pargv = argv + i;</span>
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            :     /* Is free format in use, instead of plus-style? */
<span class="lineNum">     600 </span><span class="lineCov">         27 :     free_format = 0;</span>
<span class="lineNum">     601 </span><span class="lineCov">         53 :     for (j = 1;  j &lt; argc;  j++) {</span>
<span class="lineNum">     602 </span><span class="lineCov">         26 :         if (0==strcmp (&quot;--&quot;, argv[j])) {</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :             free_format = j;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     605 </span>            :         }
<span class="lineNum">     606 </span>            :     }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineCov">         27 :     if (free_format) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :         o-&gt;pargc = free_format - (o-&gt;margc + 1);</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         o-&gt;fargc = argc - (free_format + 1);</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :         if (0 != o-&gt;fargc)</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :             o-&gt;fargv = argv + free_format + 1;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :         return o;</span>
<span class="lineNum">     614 </span>            :     }
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineCov">         27 :     for (/* empty */; i &lt; argc; i++) {</span>
<span class="lineNum">     617 </span><span class="lineCov">         26 :         if ('-' == argv[i][0]) {</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :             free (o);</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :             fprintf (stderr, &quot;+ and - style options must not be mixed\n&quot;);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     621 </span>            :         }
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineCov">         26 :         if ('+' != argv[i][0])</span>
<span class="lineNum">     624 </span><span class="lineCov">         26 :             break;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :         o-&gt;pargc++;</span>
<span class="lineNum">     626 </span>            :     }
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :     /* Handle input file names */
<span class="lineNum">     629 </span><span class="lineCov">         27 :     o-&gt;fargc = argc - i;</span>
<span class="lineNum">     630 </span><span class="lineCov">         27 :     if (0!=o-&gt;fargc)</span>
<span class="lineNum">     631 </span><span class="lineCov">         26 :         o-&gt;fargv = argv + i;</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineCov">         27 :     return o;</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
